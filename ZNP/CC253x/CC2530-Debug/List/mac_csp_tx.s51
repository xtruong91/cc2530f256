///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.30.1.3056 for 8051               21/Nov/2018  13:52:06
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
//    Command line       =  
//        -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
//        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR |
//        DEVICE_BUILD_ROUTER | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL
//        -DZNP_RUN_WDOG=FALSE -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO
//        -DZIGBEE_FRAGMENTATION -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE
//        -DSAPI_CB_FUNC=FALSE -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT
//        -DNUM_DISC_ATTEMPTS=0 -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC
//        -DMT_SAPI_FUNC -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC
//        -DMT_ZDO_MGMT -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440) -f
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c" -D
//        FEATURE_SYSTEM_STATS -D POWER_SAVING -lC
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" --diag_suppress
//        Pe001,Pa010 -o "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e
//        --no_code_motion --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\Source\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\"
//        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\" -I
//        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes
//    List file          =  
//        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\mac_csp_tx.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME mac_csp_tx

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?S_DIV_MOD
        EXTERN ?S_SHL

        FUNCTION `??cspPrepForTxProgram::?relay`,0203H
        FUNCTION `??cspReadCountSymbols::?relay`,0203H
        PUBLIC `??macCspForceTxDoneIfPending::?relay`
        FUNCTION `??macCspForceTxDoneIfPending::?relay`,0203H
        PUBLIC `??macCspTxCancelAckTimeoutCallback::?relay`
        FUNCTION `??macCspTxCancelAckTimeoutCallback::?relay`,0203H
        PUBLIC `??macCspTxGoCsma::?relay`
        FUNCTION `??macCspTxGoCsma::?relay`,0203H
        PUBLIC `??macCspTxGoGreenPower::?relay`
        FUNCTION `??macCspTxGoGreenPower::?relay`,0203H
        PUBLIC `??macCspTxGoSlotted::?relay`
        FUNCTION `??macCspTxGoSlotted::?relay`,0203H
        PUBLIC `??macCspTxIntIsr::?relay`
        FUNCTION `??macCspTxIntIsr::?relay`,0203H
        PUBLIC `??macCspTxPrepCsmaSlotted::?relay`
        FUNCTION `??macCspTxPrepCsmaSlotted::?relay`,0203H
        PUBLIC `??macCspTxPrepCsmaUnslotted::?relay`
        FUNCTION `??macCspTxPrepCsmaUnslotted::?relay`,0203H
        PUBLIC `??macCspTxPrepGreenPower::?relay`
        FUNCTION `??macCspTxPrepGreenPower::?relay`,0203H
        PUBLIC `??macCspTxPrepSlotted::?relay`
        FUNCTION `??macCspTxPrepSlotted::?relay`,0203H
        PUBLIC `??macCspTxRequestAckTimeoutCallback::?relay`
        FUNCTION `??macCspTxRequestAckTimeoutCallback::?relay`,0203H
        PUBLIC `??macCspTxReset::?relay`
        FUNCTION `??macCspTxReset::?relay`,0203H
        PUBLIC `??macCspTxStopIsr::?relay`
        FUNCTION `??macCspTxStopIsr::?relay`,0203H
        PUBWEAK RFIRQF1
        PUBWEAK RFST
        PUBWEAK S1CON
        PUBWEAK T2CSPCFG
        PUBWEAK T2IRQF
        PUBWEAK T2M0
        PUBWEAK T2M1
        PUBWEAK T2MOVF0
        PUBWEAK T2MSEL
        PUBWEAK _A_IEN0
        FUNCTION cspPrepForTxProgram,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION cspReadCountSymbols,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC macCspForceTxDoneIfPending
        FUNCTION macCspForceTxDoneIfPending,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxCancelAckTimeoutCallback
        FUNCTION macCspTxCancelAckTimeoutCallback,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxGoCsma
        FUNCTION macCspTxGoCsma,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxGoGreenPower
        FUNCTION macCspTxGoGreenPower,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxGoSlotted
        FUNCTION macCspTxGoSlotted,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC macCspTxIntIsr
        FUNCTION macCspTxIntIsr,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepCsmaSlotted
        FUNCTION macCspTxPrepCsmaSlotted,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepCsmaUnslotted
        FUNCTION macCspTxPrepCsmaUnslotted,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepGreenPower
        FUNCTION macCspTxPrepGreenPower,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepSlotted
        FUNCTION macCspTxPrepSlotted,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxRequestAckTimeoutCallback
        FUNCTION macCspTxRequestAckTimeoutCallback,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC macCspTxReset
        FUNCTION macCspTxReset,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxStopIsr
        FUNCTION macCspTxStopIsr,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
halAssertHandler    SYMBOL "halAssertHandler"
`??halAssertHandler::?relay` SYMBOL "?relay", halAssertHandler
macRxHardDisable    SYMBOL "macRxHardDisable"
`??macRxHardDisable::?relay` SYMBOL "?relay", macRxHardDisable
macRxOn             SYMBOL "macRxOn"
`??macRxOn::?relay` SYMBOL "?relay", macRxOn
macTxAckNotReceivedCallback SYMBOL "macTxAckNotReceivedCallback"
`??macTxAckNotReceivedCallback::?relay` SYMBOL "?relay", macTxAckNotReceivedCallback
macTxChannelBusyCallback SYMBOL "macTxChannelBusyCallback"
`??macTxChannelBusyCallback::?relay` SYMBOL "?relay", macTxChannelBusyCallback
macTxDoneCallback   SYMBOL "macTxDoneCallback"
`??macTxDoneCallback::?relay` SYMBOL "?relay", macTxDoneCallback
macTxTimestampCallback SYMBOL "macTxTimestampCallback"
`??macTxTimestampCallback::?relay` SYMBOL "?relay", macTxTimestampCallback
macCspForceTxDoneIfPending SYMBOL "macCspForceTxDoneIfPending"
`??macCspForceTxDoneIfPending::?relay` SYMBOL "?relay", macCspForceTxDoneIfPending
macCspTxCancelAckTimeoutCallback SYMBOL "macCspTxCancelAckTimeoutCallback"
`??macCspTxCancelAckTimeoutCallback::?relay` SYMBOL "?relay", macCspTxCancelAckTimeoutCallback
macCspTxGoCsma      SYMBOL "macCspTxGoCsma"
`??macCspTxGoCsma::?relay` SYMBOL "?relay", macCspTxGoCsma
macCspTxGoGreenPower SYMBOL "macCspTxGoGreenPower"
`??macCspTxGoGreenPower::?relay` SYMBOL "?relay", macCspTxGoGreenPower
macCspTxGoSlotted   SYMBOL "macCspTxGoSlotted"
`??macCspTxGoSlotted::?relay` SYMBOL "?relay", macCspTxGoSlotted
macCspTxIntIsr      SYMBOL "macCspTxIntIsr"
`??macCspTxIntIsr::?relay` SYMBOL "?relay", macCspTxIntIsr
macCspTxPrepCsmaSlotted SYMBOL "macCspTxPrepCsmaSlotted"
`??macCspTxPrepCsmaSlotted::?relay` SYMBOL "?relay", macCspTxPrepCsmaSlotted
macCspTxPrepCsmaUnslotted SYMBOL "macCspTxPrepCsmaUnslotted"
`??macCspTxPrepCsmaUnslotted::?relay` SYMBOL "?relay", macCspTxPrepCsmaUnslotted
macCspTxPrepGreenPower SYMBOL "macCspTxPrepGreenPower"
`??macCspTxPrepGreenPower::?relay` SYMBOL "?relay", macCspTxPrepGreenPower
macCspTxPrepSlotted SYMBOL "macCspTxPrepSlotted"
`??macCspTxPrepSlotted::?relay` SYMBOL "?relay", macCspTxPrepSlotted
macCspTxRequestAckTimeoutCallback SYMBOL "macCspTxRequestAckTimeoutCallback"
`??macCspTxRequestAckTimeoutCallback::?relay` SYMBOL "?relay", macCspTxRequestAckTimeoutCallback
macCspTxReset       SYMBOL "macCspTxReset"
`??macCspTxReset::?relay` SYMBOL "?relay", macCspTxReset
macCspTxStopIsr     SYMBOL "macCspTxStopIsr"
`??macCspTxStopIsr::?relay` SYMBOL "?relay", macCspTxStopIsr

        EXTERN `??halAssertHandler::?relay`
        FUNCTION `??halAssertHandler::?relay`,00H
        EXTERN `??macRxHardDisable::?relay`
        FUNCTION `??macRxHardDisable::?relay`,00H
        EXTERN `??macRxOn::?relay`
        FUNCTION `??macRxOn::?relay`,00H
        EXTERN `??macTxAckNotReceivedCallback::?relay`
        FUNCTION `??macTxAckNotReceivedCallback::?relay`,00H
        EXTERN `??macTxChannelBusyCallback::?relay`
        FUNCTION `??macTxChannelBusyCallback::?relay`,00H
        EXTERN `??macTxDoneCallback::?relay`
        FUNCTION `??macTxDoneCallback::?relay`,00H
        EXTERN `??macTxTimestampCallback::?relay`
        FUNCTION `??macTxTimestampCallback::?relay`,00H
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macChipVersion
        EXTERN macPib
        EXTERN macRxHardDisable
        FUNCTION macRxHardDisable,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRxOn
        FUNCTION macRxOn,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRxOnFlag
        EXTERN macTxAckNotReceivedCallback
        FUNCTION macTxAckNotReceivedCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxChannelBusyCallback
        FUNCTION macTxChannelBusyCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxCsmaBackoffDelay
        EXTERN macTxDoneCallback
        FUNCTION macTxDoneCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxGpInterframeDelay
        EXTERN macTxTimestampCallback
        FUNCTION macTxTimestampCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
//    1 /**************************************************************************************************
//    2   Filename:       mac_csp_tx.c
//    3   Revised:        $Date: 2013-05-17 11:08:52 -0700 (Fri, 17 May 2013) $
//    4   Revision:       $Revision: 34354 $
//    5 
//    6   Description:    Describe the purpose and contents of the file.
//    7 
//    8 
//    9   Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                           Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 /* hal */
//   46 #include "hal_types.h"
//   47 #include "hal_mcu.h"

        ASEGN SFR_AN:DATA:NOROOT,091H
// unsigned char volatile __sfr RFIRQF1
RFIRQF1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09bH
// unsigned char volatile __sfr S1CON
S1CON:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09cH
// unsigned char volatile __sfr T2CSPCFG
T2CSPCFG:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a1H
// unsigned char volatile __sfr T2IRQF
T2IRQF:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a2H
// unsigned char volatile __sfr T2M0
T2M0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a3H
// unsigned char volatile __sfr T2M1
T2M1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a4H
// unsigned char volatile __sfr T2MOVF0
T2MOVF0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c3H
// unsigned char volatile __sfr T2MSEL
T2MSEL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e1H
// unsigned char volatile __sfr RFST
RFST:
        DATA8
        DS 1
//   48 
//   49 /* high-level */
//   50 #include "mac_spec.h"
//   51 #include "mac_pib.h"
//   52 
//   53 /* exported low-level */
//   54 #include "mac_low_level.h"
//   55 
//   56 /* low-level specific */
//   57 #include "mac_csp_tx.h"
//   58 #include "mac_tx.h"
//   59 #include "mac_rx.h"
//   60 #include "mac_rx_onoff.h"
//   61 
//   62 /* target specific */
//   63 #include "mac_radio_defs.h"
//   64 
//   65 /* debug */
//   66 #include "mac_assert.h"
//   67 
//   68 /* ------------------------------------------------------------------------------------------------
//   69  *                                   CSP Defines / Macros
//   70  * ------------------------------------------------------------------------------------------------
//   71  */
//   72 /* immediate strobe commands */
//   73 #define ISSTART     0xE1
//   74 #define ISSTOP      0xE2
//   75 #define ISCLEAR     0xFF
//   76 
//   77 /* strobe processor instructions */
//   78 #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
//   79 #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
//   80 #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
//   81 #define WEVENT1     (0xB8)                 /* wait for MAC timer compare                          */
//   82 #define WAITX       (0xBC)                 /* wait for CSPX number of MAC timer overflows         */
//   83 #define LABEL       (0xBB)                 /* set next instruction as start of loop               */
//   84 #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
//   85 #define INT         (0xBA)                 /* assert IRQ_CSP_INT interrupt                        */
//   86 #define INCY        (0xC1)                 /* increment CSPY                                      */
//   87 #define INCMAXY(m)  (0xC8 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
//   88 #define DECX        (0xC3)                 /* decrement CSPX                                      */
//   89 #define DECY        (0xC4)                 /* decrement CSPY                                      */
//   90 #define DECZ        (0xC5)                 /* decrement CSPZ                                      */
//   91 #define RANDXY      (0xBD)                 /* load the lower CSPY bits of CSPX with random value  */
//   92 
//   93 /* strobe processor command instructions */
//   94 #define SSTOP       (0xD2)    /* stop program execution                                      */
//   95 #define SNOP        (0xD0)    /* no operation                                                */
//   96 #define STXCAL      (0xDC)    /* enable and calibrate frequency synthesizer for TX           */
//   97 #define SRXON       (0xD3)    /* turn on receiver                                            */
//   98 #define STXON       (0xD9)    /* transmit after calibration                                  */
//   99 #define STXONCCA    (0xDA)    /* transmit after calibration if CCA indicates clear channel   */
//  100 #define SRFOFF      (0xDF)    /* turn off RX/TX                                              */
//  101 #define SFLUSHRX    (0xDD)    /* flush receive FIFO                                          */
//  102 #define SFLUSHTX    (0xDE)    /* flush transmit FIFO                                         */
//  103 #define SACK        (0xD6)    /* send ACK frame                                              */
//  104 #define SACKPEND    (0xD7)    /* send ACK frame with pending bit set                         */
//  105 
//  106 /* conditions for use with instructions SKIP and RPT */
//  107 #define C_CCA_IS_VALID        0x00
//  108 #define C_SFD_IS_ACTIVE       0x01
//  109 #define C_CPU_CTRL_IS_ON      0x02
//  110 #define C_END_INSTR_MEM       0x03
//  111 #define C_CSPX_IS_ZERO        0x04
//  112 #define C_CSPY_IS_ZERO        0x05
//  113 #define C_CSPZ_IS_ZERO        0x06
//  114 #define C_RSSI_IS_VALID       0x07
//  115 
//  116 /* negated conditions for use with instructions SKIP and RPT */
//  117 #define C_NEGATE(c)   ((c) | 0x08)
//  118 #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
//  119 #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
//  120 #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
//  121 #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
//  122 #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
//  123 #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
//  124 #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
//  125 #define C_RSSI_IS_INVALID     C_NEGATE(C_RSSI_IS_VALID)
//  126 
//  127 
//  128 /* ------------------------------------------------------------------------------------------------
//  129  *                                         Defines
//  130  * ------------------------------------------------------------------------------------------------
//  131  */
//  132 
//  133 /* CSPZ return values from CSP program */
//  134 #define CSPZ_CODE_TX_DONE           0
//  135 #define CSPZ_CODE_CHANNEL_BUSY      1
//  136 #define CSPZ_CODE_TX_ACK_TIME_OUT   2
//  137 
//  138 
//  139 /* ------------------------------------------------------------------------------------------------
//  140  *                                     Local Programs
//  141  * ------------------------------------------------------------------------------------------------
//  142  */
//  143 static void  cspPrepForTxProgram(void);
//  144 static void  cspWeventSetTriggerNow(void);
//  145 static void  cspWeventSetTriggerSymbols(uint8 symbols);
//  146 static uint8 cspReadCountSymbols(void);
//  147 
//  148 
//  149 
//  150 /* ------------------------------------------------------------------------------------------------
//  151  *                                          Macros
//  152  * ------------------------------------------------------------------------------------------------
//  153  */
//  154 #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP; RFST = ISCLEAR; )
//  155 #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
//  156 
//  157 /*
//  158  *  These macros improve readability of using T2CMP in conjunction with WEVENT.
//  159  *
//  160  *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
//  161  *  It is configurable and has been set to compare against the upper byte of the timer value.
//  162  *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
//  163  *  the value of T2CMP.
//  164  *
//  165  *  Reading the timer value is done by reading the low byte first.  This latches the
//  166  *  high byte.  A trick with the ternary operator is used by a macro below to force a
//  167  *  read of the low byte when returning the value of the high byte.
//  168  *
//  169  *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT1 trigger point at the current timer count
//  170  *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT1 trigger point in symbols
//  171  *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
//  172  */
//  173 #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
//  174 
//  175 #define CSP_WEVENT_CLEAR_TRIGGER()            st( T2IRQF = (TIMER2_COMPARE1F ^ 0xFF); )
//  176 #define CSP_WEVENT_SET_TRIGGER_NOW()          cspWeventSetTriggerNow()
//  177 #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     cspWeventSetTriggerSymbols(x)
//  178 #define CSP_WEVENT_READ_COUNT_SYMBOLS()       cspReadCountSymbols()
//  179 
//  180 /*
//  181  *  Number of bits used for aligning a slotted transmit to the backoff count (plus
//  182  *  derived values).  There are restrictions on this value.  Compile time integrity
//  183  *  checks will catch an illegal setting of this value.  A full explanation accompanies
//  184  *  this compile time check (see bottom of this file).
//  185  */
//  186 #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
//  187 #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
//  188 #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
//  189 
//  190 
//  191 /**************************************************************************************************
//  192  * @fn          macCspTxReset
//  193  *
//  194  * @brief       Reset the CSP.  Immediately halts any running program.
//  195  *
//  196  * @param       none
//  197  *
//  198  * @return      none
//  199  **************************************************************************************************
//  200  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  201 MAC_INTERNAL_API void macCspTxReset(void)
macCspTxReset:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function macCspTxReset
        CODE
//  202 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  203   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.4
        MOVX    @DPTR,A
//  204   MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.3
          CFI EndBlock cfiBlock0
        REQUIRE ?Subroutine2
        REQUIRE RFST
        ; // Fall through to label ?Subroutine2
//  205   CSP_STOP_AND_CLEAR_PROGRAM();
//  206 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOVX    @DPTR,A
        MOV     0xe1,#-0x1e
        MOV     0xe1,#-0x1
        LJMP    ??Subroutine6_0 & 0xFFFF
          CFI EndBlock cfiBlock1
//  207 
//  208 
//  209 /*=================================================================================================
//  210  * @fn          cspWeventSetTriggerNow
//  211  *
//  212  * @brief       sets the WEVENT1 trigger point at the current timer count
//  213  *
//  214  * @param       none
//  215  *
//  216  * @return      symbols
//  217  *=================================================================================================
//  218  */
//  219 static void cspWeventSetTriggerNow(void)
//  220 {
//  221   halIntState_t  s;
//  222   uint8          temp0, temp1;
//  223 
//  224   /* Clear the compare interrupt flag for debugging purpose. */
//  225   CSP_WEVENT_CLEAR_TRIGGER();
//  226 
//  227   /* copy current timer count to compare */
//  228   HAL_ENTER_CRITICAL_SECTION(s);
//  229   MAC_MCU_T2_ACCESS_COUNT_VALUE();
//  230   temp0 = T2M0;
//  231   temp1 = T2M1;
//  232 
//  233   /* MAC timer bug on the cc2530 PG1 made it impossible to use
//  234    * compare = 0 for both the timer and the overflow counter.
//  235    */
//  236   if ((macChipVersion <= REV_B) && (temp0 == 0) && (temp1 == 0))
//  237   {
//  238     temp0++;
//  239   }
//  240 
//  241   MAC_MCU_T2_ACCESS_CMP1_VALUE();
//  242   T2M0 = temp0;
//  243   T2M1 = temp1;
//  244   HAL_EXIT_CRITICAL_SECTION(s);
//  245 }
//  246 
//  247 
//  248 /*=================================================================================================
//  249  * @fn          cspWeventSetTriggerSymbols
//  250  *
//  251  * @brief       sets the WEVENT1 trigger point in symbols
//  252  *
//  253  * @param       symbols
//  254  *
//  255  * @return      none
//  256  *=================================================================================================
//  257  */
//  258 static void cspWeventSetTriggerSymbols(uint8 symbols)
//  259 {
//  260   halIntState_t  s;
//  261   uint16         cmp;
//  262 
//  263   MAC_ASSERT(symbols <= MAC_A_UNIT_BACKOFF_PERIOD);
//  264 
//  265   /* Clear the compare interrupt flag for debugging purpose. */
//  266   CSP_WEVENT_CLEAR_TRIGGER();
//  267 
//  268   HAL_ENTER_CRITICAL_SECTION(s);
//  269   MAC_MCU_T2_ACCESS_CMP1_VALUE();
//  270   cmp  = (symbols) * MAC_RADIO_TIMER_TICKS_PER_SYMBOL();
//  271 
//  272   /* MAC timer bug on the cc2530 PG1 made it impossible to use
//  273    * compare = 0 for both the timer and the overflow counter.
//  274    */
//  275   if ((macChipVersion <= REV_B) && (cmp == 0))
//  276   {
//  277     cmp++;
//  278   }
//  279   T2M0 = (cmp & 0xFF);
//  280   T2M1 = (cmp >> 8);
//  281   HAL_EXIT_CRITICAL_SECTION(s);
//  282 }
//  283 
//  284 
//  285 /*=================================================================================================
//  286  * @fn          cspReadCountSymbols
//  287  *
//  288  * @brief       reads the current timer count in symbols
//  289  *
//  290  * @param       none
//  291  *
//  292  * @return      symbols
//  293  *=================================================================================================
//  294  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  295 static uint8 cspReadCountSymbols(void)
cspReadCountSymbols:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function cspReadCountSymbols
        CODE
//  296 {
        ; Saved register size: 0
        ; Auto size: 0
//  297   uint8          countLow, countHigh;
//  298   halIntState_t  s;
//  299 
//  300   HAL_ENTER_CRITICAL_SECTION(s);
        MOV     R1,0xa8+0x0
        CLR     0xa8.7
//  301   MAC_MCU_T2_ACCESS_COUNT_VALUE();
        MOV     0xc3,#0x0
//  302   countLow  = T2M0;
        MOV     R0,0xa2+0x0
//  303   countHigh = T2M1;
        MOV     R2,0xa3+0x0
//  304   HAL_EXIT_CRITICAL_SECTION(s);
        MOV     A,R1
        MOV     C,0xE0 /* A   */.7
        CLR     A
        RLC     A
        MOV     R4,A
        MOV     A,R1
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//  305 
//  306   return (((countHigh << 8) | countLow) / MAC_RADIO_TIMER_TICKS_PER_SYMBOL());
        CLR     A
        XCH     A,R2
        MOV     R1,A
        MOV     R3,#0x2
        LCALL   ?S_DIV_MOD
        MOV     A,R0
        MOV     R1,A
        LJMP    ?BRET
          CFI EndBlock cfiBlock2
        REQUIRE _A_IEN0
        REQUIRE T2MSEL
        REQUIRE T2M0
        REQUIRE T2M1
//  307 }
//  308 
//  309 
//  310 /*=================================================================================================
//  311  * @fn          cspPrepForTxProgram
//  312  *
//  313  * @brief       Prepare and initialize for transmit CSP program.
//  314  *              Call *before* loading the CSP program!
//  315  *
//  316  * @param       none
//  317  *
//  318  * @return      none
//  319  *=================================================================================================
//  320  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  321 static void cspPrepForTxProgram(void)
cspPrepForTxProgram:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function cspPrepForTxProgram
        CODE
//  322 {
        FUNCALL cspPrepForTxProgram, halAssertHandler
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  323   MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??cspPrepForTxProgram_0
        ; Setup parameters for call to function halAssertHandler
        LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
//  324 
//  325   /* set CSP EVENT1 to T2 CMP1 */
//  326   MAC_MCU_CONFIG_CSP_EVENT1();
??cspPrepForTxProgram_0:
        MOV     0x9c,#0x1
//  327 
//  328   /* set up parameters for CSP transmit program */
//  329   CSPZ = CSPZ_CODE_CHANNEL_BUSY;
        MOV     DPTR,#0x61e4
        MOV     A,#0x1
        MOVX    @DPTR,A
//  330 
//  331   /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
//  332   CSP_STOP_AND_CLEAR_PROGRAM();
        MOV     0xe1,#-0x1e
        MOV     0xe1,#-0x1
//  333   MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
        MOV     R0,0xa8+0x0
        CLR     0xa8.7
        MOV     0x9b,#0x0
        MOV     0x91,#-0x11
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        CLR     A
        RLC     A
        MOV     R2,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//  334   MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
        MOV     R1,0xa8+0x0
        CLR     0xa8.7
        MOV     0x9b,#0x0
        MOV     0x91,#-0x9
        MOV     A,R1
        MOV     C,0xE0 /* A   */.7
        CLR     A
        RLC     A
        MOV     R0,A
        MOV     A,R1
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//  335 }
        LJMP    ??Subroutine6_0 & 0xFFFF
          CFI EndBlock cfiBlock3
        REQUIRE T2CSPCFG
        REQUIRE RFST
        REQUIRE _A_IEN0
        REQUIRE S1CON
        REQUIRE RFIRQF1
//  336 
//  337 
//  338 /**************************************************************************************************
//  339  * @fn          macCspTxPrepCsmaUnslotted
//  340  *
//  341  * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
//  342  *
//  343  * @param       none
//  344  *
//  345  * @return      none
//  346  **************************************************************************************************
//  347  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  348 MAC_INTERNAL_API void macCspTxPrepCsmaUnslotted(void)
macCspTxPrepCsmaUnslotted:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function macCspTxPrepCsmaUnslotted
        CODE
//  349 {
        FUNCALL macCspTxPrepCsmaUnslotted, cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  350   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
//  351 
//  352   /*----------------------------------------------------------------------
//  353    *  Load CSP program :  Unslotted CSMA transmit
//  354    */
//  355 
//  356   /*
//  357    *  Wait for X number of backoffs, then wait for intra-backoff count
//  358    *  to reach value set for WEVENT1.
//  359    */
//  360   RFST = WAITX;
        MOV     0xe1,#-0x44
//  361   RFST = WEVENT1;
        MOV     0xe1,#-0x48
//  362 
//  363   /* wait until RSSI is valid */
//  364   RFST = WHILE(C_RSSI_IS_INVALID);
        MOV     0xe1,#0xf
//  365 
//  366   /* Note that the CCA signal is updated four clock cycles (system clock) 
//  367    * after the RSSI_VALID signal has been set.
//  368    */
//  369   RFST = SNOP;
        MOV     0xe1,#-0x30
//  370   RFST = SNOP;
        MOV     0xe1,#-0x30
//  371   RFST = SNOP;
        MOV     0xe1,#-0x30
//  372   RFST = SNOP;
        MOV     0xe1,#-0x30
//  373 
//  374   /* sample CCA, if it fails exit from here, CSPZ indicates result */
//  375   RFST = SKIP(1, C_CCA_IS_VALID);
        SJMP    ?Subroutine0
          CFI EndBlock cfiBlock4
        REQUIRE RFST
//  376   RFST = SSTOP;
//  377 
//  378   /* CSMA has passed so transmit (actual frame starts one backoff from when strobe is sent) */
//  379   RFST = STXON;
//  380 
//  381   /*
//  382    *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
//  383    *  already be active when STXON is strobed, it gets forced low.  How long this takes
//  384    *  though, is not certain.  For bulletproof operation, the first step is to wait
//  385    *  until SFD is inactive (which should be very fast if even necessary), and then wait
//  386    *  for it to go active.
//  387    */
//  388   RFST = WHILE(C_SFD_IS_ACTIVE);
//  389   RFST = WHILE(C_SFD_IS_INACTIVE);
//  390 
//  391   /*
//  392    *  Record the timestamp.  The INT instruction causes an interrupt to fire.
//  393    *  The ISR for this interrupt records the timestamp (which was just captured
//  394    *  when SFD went high).
//  395    */
//  396   RFST = INT;
//  397 
//  398   /*
//  399    *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
//  400    *  the transmit was successful.
//  401    */
//  402   RFST = WHILE(C_SFD_IS_ACTIVE);
//  403   RFST = DECZ;
//  404 
//  405   /*
//  406    * CC2530 requires SSTOP to generate CSP_STOP interrupt.
//  407    */
//  408   RFST = SSTOP;
//  409 }
//  410 
//  411 
//  412 /**************************************************************************************************
//  413  * @fn          macCspTxPrepCsmaSlotted
//  414  *
//  415  * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
//  416  *
//  417  * @param       none
//  418  *
//  419  * @return      none
//  420  **************************************************************************************************
//  421  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  422 MAC_INTERNAL_API void macCspTxPrepCsmaSlotted(void)
macCspTxPrepCsmaSlotted:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function macCspTxPrepCsmaSlotted
        CODE
//  423 {
        FUNCALL macCspTxPrepCsmaSlotted, cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  424   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
//  425 
//  426   /*----------------------------------------------------------------------
//  427    *  Load CSP program :  Slotted CSMA transmit
//  428    */
//  429 
//  430   /* wait for X number of backoffs */
//  431   RFST = WAITX;
        MOV     0xe1,#-0x44
//  432   
//  433   /* sample RSSI, if it is valid then skip one extra backoff. */
//  434   RFST = SKIP(1, C_RSSI_IS_VALID);
        MOV     0xe1,#0x17
//  435   
//  436   /* wait for one backoff to guarantee receiver has been on at least that long */
//  437   RFST = WAITW(1);
        MOV     0xe1,#-0x7f
//  438 
//  439   /* sample CCA, if it fails exit from here, CSPZ indicates result */
//  440   RFST = SKIP(1, C_CCA_IS_VALID);
        MOV     0xe1,#0x10
//  441   RFST = SSTOP;
        MOV     0xe1,#-0x2e
//  442 
//  443   /* per slotted CSMA-CCA in specification, wait one backoff */
//  444   RFST = WAITW(1);
        MOV     0xe1,#-0x7f
//  445 
//  446   /* sample CCA again, if it fails exit from here, CSPZ indicates result */
//  447   RFST = SKIP(1, C_CCA_IS_VALID);
        SJMP    ?Subroutine0
          CFI EndBlock cfiBlock5
        REQUIRE RFST
//  448   RFST = SSTOP;
//  449 
//  450   /* CSMA has passed so transmit */
//  451   RFST = STXON;
//  452 
//  453   /*
//  454    *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
//  455    *  already be active when STXON is strobed, it gets forced low.  How long this takes
//  456    *  though, is not certain.  For bulletproof operation, the first step is to wait
//  457    *  until SFD is inactive (which should be very fast if even necessary), and then wait
//  458    *  for it to go active.
//  459    */
//  460   RFST = WHILE(C_SFD_IS_ACTIVE);
//  461   RFST = WHILE(C_SFD_IS_INACTIVE);
//  462 
//  463   /*
//  464    *  Record the timestamp.  The INT instruction causes an interrupt to fire.
//  465    *  The ISR for this interrupt records the timestamp (which was just captured
//  466    *  when SFD went high).
//  467    */
//  468   RFST = INT;
//  469 
//  470   /*
//  471    *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
//  472    *  the transmit was successful.
//  473    */
//  474   RFST = WHILE(C_SFD_IS_ACTIVE);
//  475   RFST = DECZ;
//  476 
//  477   /*
//  478    * CC2530 requires SSTOP to generate CSP_STOP interrupt.
//  479    */
//  480   RFST = SSTOP;
//  481 }
//  482 
//  483 
//  484 /**************************************************************************************************
//  485  * @fn          macCspTxGoCsma
//  486  *
//  487  * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
//  488  *              slotted or unslotted CSMA transmits.  When CSP program has finished,
//  489  *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
//  490  *              turn call macTxDoneCallback().
//  491  *
//  492  * @param       none
//  493  *
//  494  * @return      none
//  495  **************************************************************************************************
//  496  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  497 MAC_INTERNAL_API void macCspTxGoCsma(void)
macCspTxGoCsma:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function macCspTxGoCsma
        CODE
//  498 {
        FUNCALL macCspTxGoCsma, macRxOn
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  499   /*
//  500    *  Set CSPX with the countdown time of the CSMA delay.
//  501    */
//  502   CSPX = macTxCsmaBackoffDelay;
        MOV     DPTR,#macTxCsmaBackoffDelay
        MOVX    A,@DPTR
        MOV     DPTR,#0x61e2
        MOVX    @DPTR,A
//  503 
//  504   /*
//  505    *  Set WEVENT to trigger at the current value of the timer.  This allows
//  506    *  unslotted CSMA to transmit just a little bit sooner.
//  507    */
//  508   CSP_WEVENT_SET_TRIGGER_NOW();
        MOV     0xa1,#-0x3
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R2,A
        CLR     0xa8.7
        MOV     0xc3,#0x0
        MOV     R0,0xa2+0x0
        MOV     R1,0xa3+0x0
        MOV     DPTR,#macChipVersion
        MOVX    A,@DPTR
        SUBB    A,#0x12
        JNC     ??macCspTxGoCsma_0
        MOV     A,R0
        JNZ     ??macCspTxGoCsma_0
        MOV     A,R1
        JNZ     ??macCspTxGoCsma_0
        MOV     R0,#0x1
??macCspTxGoCsma_0:
        MOV     0xc3,#0x3
        MOV     0xa2,R0
        MOV     0xa3,R1
        MOV     A,R2
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  509 
//  510   /*
//  511    *  Enable interrupt that fires when CSP program stops.
//  512    *  Also enable interrupt that fires when INT instruction
//  513    *  is executed.
//  514    */
//  515   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
          CFI EndBlock cfiBlock6
        REQUIRE ?Subroutine1
        REQUIRE RFST
        REQUIRE T2IRQF
        REQUIRE _A_IEN0
        REQUIRE T2MSEL
        REQUIRE T2M0
        REQUIRE T2M1
        ; // Fall through to label ?Subroutine1
//  516   MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
//  517 
//  518   /*
//  519    *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
//  520    *  least one backoff before performing clear channel assessment (CCA).
//  521    */
//  522   macRxOn();
//  523 
//  524   /* start the CSP program */
//  525   CSP_START_PROGRAM();
//  526 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_0:
        ; Setup parameters for call to function macRxOn
        ; Setup parameters for call to function macRxOn
        LCALL   `??macRxOn::?relay`  ; Banked call to: macRxOn
        MOV     0xe1,#-0x1f
        SJMP    ??Subroutine6_0
          CFI EndBlock cfiBlock7

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOV     0xe1,#0x10
        MOV     0xe1,#-0x2e
          CFI EndBlock cfiBlock8
        REQUIRE ??Subroutine4_0
        ; // Fall through to label ??Subroutine4_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine4_0:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOV     0xe1,#-0x27
        MOV     0xe1,#0x1
        MOV     0xe1,#0x9
        MOV     0xe1,#-0x46
        MOV     0xe1,#0x1
          CFI EndBlock cfiBlock9
        REQUIRE ??Subroutine5_0
        ; // Fall through to label ??Subroutine5_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine5_0:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOV     0xe1,#-0x3b
        MOV     0xe1,#-0x2e
          CFI EndBlock cfiBlock10
        REQUIRE ??Subroutine6_0
        ; // Fall through to label ??Subroutine6_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine6_0:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
          CFI CFA_SP SP+-4
          CFI DPH0 SameValue
        POP     DPL
          CFI CFA_SP SP+-3
          CFI DPL0 SameValue
        LJMP    ?BRET
          CFI EndBlock cfiBlock11
//  527 
//  528 
//  529 /**************************************************************************************************
//  530  * @fn          macCspTxPrepSlotted
//  531  *
//  532  * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
//  533  *              Load CSP program and set CSP parameters.
//  534  *
//  535  * @param       none
//  536  *
//  537  * @return      none
//  538  **************************************************************************************************
//  539  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  540 MAC_INTERNAL_API void macCspTxPrepSlotted(void)
macCspTxPrepSlotted:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function macCspTxPrepSlotted
        CODE
//  541 {
        FUNCALL macCspTxPrepSlotted, cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  542   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
//  543 
//  544   /*----------------------------------------------------------------------
//  545    *  Load CSP program :  Slotted transmit (no CSMA)
//  546    */
//  547 
//  548   /* wait for X number of backoffs */
//  549   RFST = WAITX;
        MOV     0xe1,#-0x44
//  550 
//  551   /* just transmit, no CSMA required */
//  552   RFST = STXON;
        SJMP    ??Subroutine4_0
          CFI EndBlock cfiBlock12
        REQUIRE RFST
//  553 
//  554   /*
//  555    *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
//  556    *  already be active when STXON is strobed, it gets forced low.  How long this takes
//  557    *  though, is not certain.  For bulletproof operation, the first step is to wait
//  558    *  until SFD is inactive (which should be very fast if even necessary), and then wait
//  559    *  for it to go active.
//  560    */
//  561   RFST = WHILE(C_SFD_IS_ACTIVE);
//  562   RFST = WHILE(C_SFD_IS_INACTIVE);
//  563 
//  564   /*
//  565    *  Record the timestamp.  The INT instruction causes an interrupt to fire.
//  566    *  The ISR for this interrupt records the timestamp (which was just captured
//  567    *  when SFD went high).
//  568    */
//  569   RFST = INT;
//  570 
//  571   /*
//  572    *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
//  573    *  the transmit was successful.
//  574    */
//  575   RFST = WHILE(C_SFD_IS_ACTIVE);
//  576   RFST = DECZ;
//  577 
//  578   /*
//  579    * CC2530 requires SSTOP to generate CSP_STOP interrupt.
//  580    */
//  581   RFST = SSTOP;
//  582 
//  583 }
//  584 
//  585 
//  586 /**************************************************************************************************
//  587  * @fn          macCspTxGoSlotted
//  588  *
//  589  * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
//  590  *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
//  591  *              This ISR will in turn call macTxDoneCallback().
//  592  *
//  593  * @param       none
//  594  *
//  595  * @return      none
//  596  **************************************************************************************************
//  597  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  598 MAC_INTERNAL_API void macCspTxGoSlotted(void)
macCspTxGoSlotted:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function macCspTxGoSlotted
        CODE
//  599 {
        FUNCALL macCspTxGoSlotted, macRxHardDisable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  600   halIntState_t  s;
//  601   uint8 lowByteOfBackoffCount;
//  602   uint8 backoffCountdown;
//  603 
//  604   /*
//  605    *  Enable interrupt that fires when CSP program stops.
//  606    *  Also enable interrupt that fires when INT instruction
//  607    *  is executed.
//  608    */
//  609   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
        LCALL   ?Subroutine3 & 0xFFFF
//  610   MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
//  611 
//  612   /* critical section needed for timer accesses */
//  613   HAL_ENTER_CRITICAL_SECTION(s);
??CrossCallReturnLabel_1:
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     ?V0,A
        CLR     0xa8.7
//  614 
//  615   /* store lowest byte of backoff count (same as lowest byte of overflow count) */
//  616   MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
        MOV     0xc3,#0x0
//  617 
//  618   /* Latch T2MOVFx */
//  619   T2M0;
        MOV     A,0xa2
//  620   lowByteOfBackoffCount = T2MOVF0;
        MOV     R7,0xa4+0x0
//  621 
//  622   /*
//  623    *  Compute the number of backoffs until time to strobe transmit.  The strobe should
//  624    *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
//  625    *  countdown value is to determine when the lower bits would rollover and become zero,
//  626    *  and then subtract one.
//  627    */
//  628   backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
        MOV     A,#0xf
        ANL     A,R7
        MOV     R0,A
        MOV     A,#0xf
        SUBB    A,R0
        MOV     R6,A
//  629 
//  630   /*
//  631    *  Store backoff countdown value into CSPX.
//  632    *
//  633    *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
//  634    *  CSP program will immediately continue if CSPX is zero when executed.  However,
//  635    *  if the countdown is zero, it means the transmit function was not called early
//  636    *  enough for a properly timed slotted transmit.  The transmit will be late.
//  637    */
//  638   CSPX = backoffCountdown;
        MOV     DPTR,#0x61e2
        MOVX    @DPTR,A
//  639 
//  640   /* Disable Rx and flush RXFIFO due to chip bug #1546 */
//  641   macRxHardDisable();
        ; Setup parameters for call to function macRxHardDisable
        LCALL   `??macRxHardDisable::?relay`; Banked call to: macRxHardDisable
//  642 
//  643   /*
//  644    *  The receiver will be turned on during CSP execution, guaranteed.
//  645    *  Since it is not possible to update C variables within the CSP,
//  646    *  the new "on" state of the receiver must be set a little early
//  647    *  here before the CSP is started.
//  648    */
//  649   MAC_RX_WAS_FORCED_ON();
        MOV     DPTR,#macRxOnFlag
        MOV     A,#0x1
        MOVX    @DPTR,A
//  650 
//  651   /* start the CSP program */
//  652   CSP_START_PROGRAM();
        MOV     0xe1,#-0x1f
//  653 
//  654   /*
//  655    *  If the previous stored low byte of the backoff count is no longer equal to
//  656    *  the current value, a rollover has occurred.  This means the backoff countdown
//  657    *  stored in CSPX may not be correct.
//  658    *
//  659    *  In this case, the value of CSPX is reloaded to reflect the correct backoff
//  660    *  countdown value (this is one less than what was just used as a rollover has
//  661    *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
//  662    *  of another rollover occurring.  This means the value written to CSPX is guaranteed
//  663    *  to be accurate.
//  664    *
//  665    *  Also, the logic below ensures that the value written to CSPX is at least one.
//  666    *  This is needed for correct operation of the WAITX instruction.  As with an
//  667    *  initial backoff countdown value of zero, if this case does occur, it means the
//  668    *  transmit function was not called early enough for a properly timed slotted transmit.
//  669    *  The transmit will be late.
//  670    *
//  671    *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
//  672    *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
//  673    *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
//  674    *  collision is not possible (still within a critical section here too).
//  675    */
//  676   MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
        MOV     0xc3,#0x0
//  677 
//  678   /* Latch T2MOVFx */
//  679   T2M0;
        MOV     A,0xa2
//  680   if ((lowByteOfBackoffCount != T2MOVF0) && (backoffCountdown > 1))
        MOV     A,0xa4
        XRL     A,R7
        JZ      ??macCspTxGoSlotted_0
        MOV     A,R6
        CLR     C
        SUBB    A,#0x2
        JC      ??macCspTxGoSlotted_0
//  681   {
//  682     CSPX = backoffCountdown - 1;
        MOV     A,#-0x1
        ADD     A,R6
        MOV     DPTR,#0x61e2
        MOVX    @DPTR,A
//  683   }
//  684 
//  685   HAL_EXIT_CRITICAL_SECTION(s);
??macCspTxGoSlotted_0:
        MOV     A,?V0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  686 }
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock13
        REQUIRE _A_IEN0
        REQUIRE T2MSEL
        REQUIRE T2M0
        REQUIRE T2MOVF0
        REQUIRE RFST

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
          CFI Block cfiCond14 Using cfiCommon0
          CFI Function macCspTxGoCsma
          CFI Conditional ??CrossCallReturnLabel_0
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond15 Using cfiCommon0
          CFI (cfiCond15) Function macCspTxGoGreenPower
          CFI (cfiCond15) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond15) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond15) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond15) CFA_SP SP+-7
          CFI Block cfiCond16 Using cfiCommon0
          CFI (cfiCond16) Function macCspTxGoSlotted
          CFI (cfiCond16) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond16) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond16) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond16) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond16) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond16) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond16) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond16) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond16) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond16) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond16) CFA_SP SP+-2
          CFI (cfiCond16) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiPicker17 Using cfiCommon1
          CFI (cfiPicker17) NoFunction
          CFI (cfiPicker17) Picker
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.4
        MOVX    @DPTR,A
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.3
        MOVX    @DPTR,A
        RET
          CFI EndBlock cfiCond14
          CFI EndBlock cfiCond15
          CFI EndBlock cfiCond16
          CFI EndBlock cfiPicker17
//  687 
//  688 
//  689 /**************************************************************************************************
//  690  * @fn          macCspTxPrepGreenPower
//  691  *
//  692  * @brief       Prepare CSP for "Green Power" transmit.  Load CSP program and set CSP parameters.
//  693  *
//  694  * @param       none
//  695  *
//  696  * @return      none
//  697  **************************************************************************************************
//  698  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  699 MAC_INTERNAL_API void macCspTxPrepGreenPower(void)
macCspTxPrepGreenPower:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function macCspTxPrepGreenPower
        CODE
//  700 {
        FUNCALL macCspTxPrepGreenPower, cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  701   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
//  702 
//  703   /*----------------------------------------------------------------------
//  704    *  Load CSP program :  Green Power transmit
//  705    */
//  706   
//  707   /* Set the next STXON as a lable */
//  708   RFST = LABEL;
        MOV     0xe1,#-0x45
//  709   
//  710   /* wait for number of backoffs for interframe spacing */
//  711   RFST = WAITW(macTxGpInterframeDelay);
        MOV     DPTR,#macTxGpInterframeDelay
        MOVX    A,@DPTR
        ANL     A,#0x1f
        ORL     A,#0x80
        MOV     0xe1,A
//  712   
//  713   /* Transmit (actual frame starts one backoff from when strobe is sent) */
//  714   RFST = STXON;
        MOV     0xe1,#-0x27
//  715 
//  716   /*
//  717    *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
//  718    *  already be active when STXON is strobed, it gets forced low.  How long this takes
//  719    *  though, is not certain.  For bulletproof operation, the first step is to wait
//  720    *  until SFD is inactive (which should be very fast if even necessary), and then wait
//  721    *  for it to go active.
//  722    */
//  723   RFST = WHILE(C_SFD_IS_ACTIVE);
        MOV     0xe1,#0x1
//  724   RFST = WHILE(C_SFD_IS_INACTIVE);
        MOV     0xe1,#0x9
//  725 
//  726   /*
//  727    *  Record the timestamp.  The INT instruction causes an interrupt to fire.
//  728    *  The ISR for this interrupt records the timestamp (which was just captured
//  729    *  when SFD went high).
//  730    */
//  731   RFST = INT;
        MOV     0xe1,#-0x46
//  732 
//  733   /*
//  734    *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
//  735    *  the transmit was successful.
//  736    */
//  737   RFST = WHILE(C_SFD_IS_ACTIVE);
        MOV     0xe1,#0x1
//  738   RFST = DECX;
        MOV     0xe1,#-0x3d
//  739 
//  740   /* Go to the STXON label for repeat transmissions */
//  741   RFST = RPT(C_CSPX_IS_NON_ZERO);
        MOV     0xe1,#-0x54
//  742   
//  743   /* Clear the busy status */
//  744   RFST = DECZ;
        LJMP    ??Subroutine5_0 & 0xFFFF
          CFI EndBlock cfiBlock18
        REQUIRE RFST
//  745   
//  746   /*
//  747    * CC2530 requires SSTOP to generate CSP_STOP interrupt.
//  748    */
//  749   RFST = SSTOP;
//  750 }
//  751 
//  752 
//  753 /**************************************************************************************************
//  754  * @fn          macCspTxGoGreenPower
//  755  *
//  756  * @brief       Run previously loaded CSP program for Green Power transmit.  When CSP program 
//  757  *              has finished, an interrupt occurs and macCspTxStopIsr() is called.  This ISR 
//  758  *              will in turn call macTxDoneCallback().
//  759  *
//  760  * @param       none
//  761  *
//  762  * @return      none
//  763  **************************************************************************************************
//  764  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  765 MAC_INTERNAL_API void macCspTxGoGreenPower(void)
macCspTxGoGreenPower:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function macCspTxGoGreenPower
        CODE
//  766 {
        FUNCALL macCspTxGoGreenPower, macRxOn
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  767   /*
//  768    *  Set CSPX with the countdown of number of Green Power transmissions.
//  769    */
//  770   CSPX = macTxCsmaBackoffDelay;
        MOV     DPTR,#macTxCsmaBackoffDelay
        MOVX    A,@DPTR
        MOV     DPTR,#0x61e2
        MOVX    @DPTR,A
//  771 
//  772   /*
//  773    *  Enable interrupt that fires when CSP program stops.
//  774    *  Also enable interrupt that fires when INT instruction
//  775    *  is executed.
//  776    */
//  777   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
        LJMP    ?Subroutine1 & 0xFFFF
          CFI EndBlock cfiBlock19
        REQUIRE RFST
//  778   MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
//  779 
//  780   /*
//  781    *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
//  782    *  least one backoff before performing clear channel assessment (CCA).
//  783    */
//  784   macRxOn();
//  785 
//  786   /* start the CSP program */
//  787   CSP_START_PROGRAM();
//  788 }
//  789 
//  790 
//  791 /**************************************************************************************************
//  792  * @fn          macCspForceTxDoneIfPending
//  793  *
//  794  * @brief       The function clears out any pending TX done logic.  Used by receive logic
//  795  *              to make sure its ISR does not prevent transmit from completing in a reasonable
//  796  *              amount of time.
//  797  *
//  798  * @param       none
//  799  *
//  800  * @return      none
//  801  **************************************************************************************************
//  802  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  803 MAC_INTERNAL_API void macCspForceTxDoneIfPending(void)
macCspForceTxDoneIfPending:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function macCspForceTxDoneIfPending
        CODE
//  804 {
        FUNCALL macCspForceTxDoneIfPending, macCspTxIntIsr
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspForceTxDoneIfPending, macTxDoneCallback
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  805   if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
        MOV     DPTR,#0x61e4
        MOVX    A,@DPTR
        JNZ     ??macCspForceTxDoneIfPending_0
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??macCspForceTxDoneIfPending_0
//  806   {
//  807     MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.4
        MOVX    @DPTR,A
//  808     if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??macCspForceTxDoneIfPending_1
//  809     {
//  810       macCspTxIntIsr();
        ; Setup parameters for call to function macCspTxIntIsr
        LCALL   `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
//  811     }
//  812     macTxDoneCallback();
??macCspForceTxDoneIfPending_1:
        ; Setup parameters for call to function macTxDoneCallback
        LCALL   `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
//  813   }
//  814 }
??macCspForceTxDoneIfPending_0:
        LJMP    ??Subroutine6_0 & 0xFFFF
          CFI EndBlock cfiBlock20
//  815 
//  816 
//  817 /**************************************************************************************************
//  818  * @fn          macCspTxRequestAckTimeoutCallback
//  819  *
//  820  * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
//  821  *              the function macCspTxStopIsr() is called via an interrupt.
//  822  *
//  823  * @param       none
//  824  *
//  825  * @return      none
//  826  **************************************************************************************************
//  827  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  828 MAC_INTERNAL_API void macCspTxRequestAckTimeoutCallback(void)
macCspTxRequestAckTimeoutCallback:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function macCspTxRequestAckTimeoutCallback
        CODE
//  829 {
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxRequestAckTimeoutCallback, cspReadCountSymbols
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxRequestAckTimeoutCallback, cspReadCountSymbols
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  830   uint8 startSymbol;
//  831   uint8 symbols;
//  832   uint8 rollovers;
//  833 
//  834   MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??macCspTxRequestAckTimeoutCallback_0
        ; Setup parameters for call to function halAssertHandler
        LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
//  835 
//  836   /* record current symbol count */
//  837   startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
??macCspTxRequestAckTimeoutCallback_0:
        ; Setup parameters for call to function cspReadCountSymbols
        LCALL   `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
        MOV     A,R1
        MOV     ?V2,A
//  838 
//  839   /* set symbol timeout from PIB */
//  840   symbols = macPib.ackWaitDuration;
        MOV     DPTR,#macPib
        MOVX    A,@DPTR
        MOV     R6,A
//  841 
//  842   /* make sure delay value is not too small for logic to handle */
//  843   MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
        CLR     C
        SUBB    A,#0x15
        JNC     ??macCspTxRequestAckTimeoutCallback_1
        ; Setup parameters for call to function halAssertHandler
        LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
//  844 
//  845   /* subtract out symbols left in current backoff period */
//  846   symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
??macCspTxRequestAckTimeoutCallback_1:
        MOV     A,#-0x14
        ADD     A,?V2
        ADD     A,R6
        MOV     R6,A
//  847 
//  848   /* calculate rollovers needed for remaining symbols */
//  849   rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
        MOV     B,#0x14
        DIV     AB
        MOV     R7,A
//  850 
//  851   /* calculate symbols that still need counted after last rollover */
//  852   symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
        MOV     B,#0x14
        MUL     AB
        XCH     A,R6
        SUBB    A,R6
        MOV     R6,A
//  853 
//  854   /* add one to rollovers to account for symbols remaining in the current backoff period */
//  855   rollovers++;
        INC     R7
//  856 
//  857   /* set up parameters for CSP program */
//  858   CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
        MOV     DPTR,#0x61e4
        MOV     A,#0x2
        MOVX    @DPTR,A
//  859   CSPX = rollovers;
        MOV     A,R7
        MOV     DPTR,#0x61e2
        MOVX    @DPTR,A
//  860   CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
        MOV     A,R6
        CLR     C
        SUBB    A,#0x15
        JC      ??macCspTxRequestAckTimeoutCallback_2
        ; Setup parameters for call to function halAssertHandler
        LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
??macCspTxRequestAckTimeoutCallback_2:
        MOV     0xa1,#-0x3
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R2,A
        CLR     0xa8.7
        MOV     0xc3,#0x3
        MOV     ?V0,R6
        MOV     ?V1,#0x0
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,A
        MOV     R1,?V1
        MOV     DPTR,#macChipVersion
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x12
        JNC     ??macCspTxRequestAckTimeoutCallback_3
        MOV     A,R1
        JNZ     ??macCspTxRequestAckTimeoutCallback_3
        INC     R0
        MOV     R1,#0x0
??macCspTxRequestAckTimeoutCallback_3:
        MOV     A,R0
        MOV     0xa2,A
        MOV     A,R1
        MOV     0xa3,A
        MOV     A,R2
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  861 
//  862   /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
//  863   CSP_STOP_AND_CLEAR_PROGRAM();
        MOV     0xe1,#-0x1e
        MOV     0xe1,#-0x1
//  864   MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
        MOV     R0,0xa8+0x0
        CLR     0xa8.7
        MOV     0x9b,#0x0
        MOV     0x91,#-0x11
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        CLR     A
        RLC     A
        MOV     R6,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//  865 
//  866   /*--------------------------
//  867    * load CSP program
//  868    */
//  869   RFST = WAITX;
        MOV     0xe1,#-0x44
//  870   RFST = WEVENT1;
        MOV     0xe1,#-0x48
//  871   RFST = SSTOP;
        MOV     0xe1,#-0x2e
//  872 
//  873   /*--------------------------
//  874    */
//  875 
//  876   /* run CSP program */
//  877   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.4
        MOVX    @DPTR,A
//  878   CSP_START_PROGRAM();
        MOV     0xe1,#-0x1f
//  879 
//  880   /*
//  881    *  For bullet proof operation, must account for the boundary condition
//  882    *  where a rollover occurs after count was read but before CSP program
//  883    *  was started.
//  884    *
//  885    *  If current symbol count is less that the symbol count recorded at the
//  886    *  start of this function, a rollover has occurred.
//  887    */
//  888   if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
        ; Setup parameters for call to function cspReadCountSymbols
        LCALL   `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
        MOV     A,R1
        CLR     C
        SUBB    A,?V2
        JNC     ??macCspTxRequestAckTimeoutCallback_4
//  889   {
//  890     /* a rollover has occurred, make sure it was accounted for */
//  891     if (CSPX == rollovers)
        MOV     DPTR,#0x61e2
        MOVX    A,@DPTR
        XRL     A,R7
        JNZ     ??macCspTxRequestAckTimeoutCallback_4
//  892     {
//  893       /*
//  894        *  Rollover event missed, manually decrement CSPX to adjust.
//  895        *
//  896        *  Note : there is a very small chance that CSPX does not
//  897        *  get decremented.  This would occur if CSPX were written
//  898        *  at exactly the same time a timer overflow is occurring (which
//  899        *  causes the CSP instruction WAITX to decrement CSPX).  This
//  900        *  would be extremely rare, but if it does happen, the only
//  901        *  consequence is that the ACK timeout period is extended
//  902        *  by one backoff.
//  903        */
//  904       CSPX--;
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
//  905     }
//  906   }
//  907 }
??macCspTxRequestAckTimeoutCallback_4:
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock21
        REQUIRE RFST
        REQUIRE _A_IEN0
        REQUIRE S1CON
        REQUIRE RFIRQF1
        REQUIRE T2IRQF
        REQUIRE T2MSEL
        REQUIRE T2M0
        REQUIRE T2M1
//  908 
//  909 
//  910 /**************************************************************************************************
//  911  * @fn          macCspTxCancelAckTimeoutCallback
//  912  *
//  913  * @brief       Cancels previous request for ACK timeout callback.
//  914  *
//  915  * @param       none
//  916  *
//  917  * @return      none
//  918  **************************************************************************************************
//  919  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  920 MAC_INTERNAL_API void macCspTxCancelAckTimeoutCallback(void)
macCspTxCancelAckTimeoutCallback:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function macCspTxCancelAckTimeoutCallback
        CODE
//  921 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  922   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.4
        LJMP    ?Subroutine2 & 0xFFFF
          CFI EndBlock cfiBlock22
        REQUIRE RFST
//  923   CSP_STOP_AND_CLEAR_PROGRAM();
//  924 }
//  925 
//  926 
//  927 /**************************************************************************************************
//  928  * @fn          macCspTxIntIsr
//  929  *
//  930  * @brief       Interrupt service routine for handling INT type interrupts from CSP.
//  931  *              This interrupt happens when the CSP instruction INT is executed.  It occurs
//  932  *              once the SFD signal goes high indicating that transmit has successfully
//  933  *              started.  The timer value has been captured at this point and timestamp
//  934  *              can be stored.
//  935  *
//  936  * @param       none
//  937  *
//  938  * @return      none
//  939  **************************************************************************************************
//  940  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  941 MAC_INTERNAL_API void macCspTxIntIsr(void)
macCspTxIntIsr:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function macCspTxIntIsr
        CODE
//  942 {
        FUNCALL macCspTxIntIsr, macTxTimestampCallback
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  943   MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.3
        MOVX    @DPTR,A
//  944 
//  945   /* execute callback function that records transmit timestamp */
//  946   macTxTimestampCallback();
        ; Setup parameters for call to function macTxTimestampCallback
        LCALL   `??macTxTimestampCallback::?relay`; Banked call to: macTxTimestampCallback
//  947 }
        LJMP    ??Subroutine6_0 & 0xFFFF
          CFI EndBlock cfiBlock23
//  948 
//  949 
//  950 /**************************************************************************************************
//  951  * @fn          macCspTxStopIsr
//  952  *
//  953  * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
//  954  *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
//  955  *              program, 2) executing SSTOP within the program, 3) executing immediate
//  956  *              instruction ISSTOP.
//  957  *
//  958  *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
//  959  *              is the end of a transmit.
//  960  *
//  961  * @param       none
//  962  *
//  963  * @return      none
//  964  **************************************************************************************************
//  965  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  966 MAC_INTERNAL_API void macCspTxStopIsr(void)
macCspTxStopIsr:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function macCspTxStopIsr
        CODE
//  967 {
        FUNCALL macCspTxStopIsr, macTxDoneCallback
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxStopIsr, macTxChannelBusyCallback
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxStopIsr, halAssertHandler
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macCspTxStopIsr, macTxAckNotReceivedCallback
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  968   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        MOV     DPTR,#0x61a4
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.4
        MOVX    @DPTR,A
//  969 
//  970   if (CSPZ == CSPZ_CODE_TX_DONE)
        MOV     DPTR,#0x61e4
        MOVX    A,@DPTR
        JNZ     ??macCspTxStopIsr_0
//  971   {
//  972     macTxDoneCallback();
        ; Setup parameters for call to function macTxDoneCallback
        LCALL   `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
        SJMP    ??macCspTxStopIsr_1
//  973   }
//  974   else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
??macCspTxStopIsr_0:
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??macCspTxStopIsr_2
//  975   {
//  976     macTxChannelBusyCallback();
        ; Setup parameters for call to function macTxChannelBusyCallback
        LCALL   `??macTxChannelBusyCallback::?relay`; Banked call to: macTxChannelBusyCallback
        SJMP    ??macCspTxStopIsr_1
//  977   }
//  978   else
//  979   {
//  980     MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
??macCspTxStopIsr_2:
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      ??macCspTxStopIsr_3
        ; Setup parameters for call to function halAssertHandler
        LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
//  981     macTxAckNotReceivedCallback();
??macCspTxStopIsr_3:
        ; Setup parameters for call to function macTxAckNotReceivedCallback
        LCALL   `??macTxAckNotReceivedCallback::?relay`; Banked call to: macTxAckNotReceivedCallback
//  982   }
//  983 }
??macCspTxStopIsr_1:
        LJMP    ??Subroutine6_0 & 0xFFFF
          CFI EndBlock cfiBlock24

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxReset::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxReset

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??cspReadCountSymbols::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    cspReadCountSymbols

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??cspPrepForTxProgram::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    cspPrepForTxProgram

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxPrepCsmaUnslotted::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxPrepCsmaUnslotted

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxPrepCsmaSlotted::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxPrepCsmaSlotted

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxGoCsma::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxGoCsma

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxPrepSlotted::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxPrepSlotted

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxGoSlotted::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxGoSlotted

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxPrepGreenPower::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxPrepGreenPower

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxGoGreenPower::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxGoGreenPower

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspForceTxDoneIfPending::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspForceTxDoneIfPending

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxRequestAckTimeoutCallback::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxRequestAckTimeoutCallback

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxCancelAckTimeoutCallback::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxCancelAckTimeoutCallback

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxIntIsr::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxIntIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??macCspTxStopIsr::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    macCspTxStopIsr

        END
//  984 
//  985 
//  986 
//  987 /**************************************************************************************************
//  988  *                                  Compile Time Integrity Checks
//  989  **************************************************************************************************
//  990  */
//  991 
//  992 #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
//  993 #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
//  994 #endif
//  995 
//  996 #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
//  997 #error "WARNING!  This define value changed.  It was selected for optimum performance."
//  998 #endif
//  999 
// 1000 #if (T2THD_TICKS_PER_SYMBOL == 0)
// 1001 #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
// 1002 #endif
// 1003 
// 1004 #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
// 1005 #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
// 1006 #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
// 1007 /*
// 1008  *  In other words, the backoff count for the number of superframe rolls over before the
// 1009  *  specified number of bits rollover.  For example, if backoff count for a superframe
// 1010  *  rolls over at 48, the binary number immediately before a rollover is 00101111.
// 1011  *  In this case four bits would work as an alignment mask.  Five would not work though as
// 1012  *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
// 1013  *  would be expected) because it a new superframe is starting.
// 1014  */
// 1015 #endif
// 1016 #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
// 1017 #error "ERROR!  Not enough backoff countdown bits to be practical."
// 1018 #endif
// 1019 
// 1020 
// 1021 /**************************************************************************************************
// 1022 */
// 
// 767 bytes in segment BANKED_CODE
//  90 bytes in segment BANK_RELAYS
//  10 bytes in segment SFR_AN
// 
// 857 bytes of CODE memory
//   0 bytes of DATA memory (+ 10 bytes shared)
//
//Errors: none
//Warnings: none

###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Nov/2018  13:52:06
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
#    Command line       =  
#        -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -f "D:\1.embedded\kit\cc2530\Reference\Z-Stack
#        Mesh 1.0.0\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c" -D
#        FEATURE_SYSTEM_STATS -D POWER_SAVING -lC
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" --diag_suppress
#        Pe001,Pa010 -o "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e --no_code_motion
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\" -I
#        "D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\mac_csp_tx.lst
#    Object file        =  
#        D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj\mac_csp_tx.r51
#
###############################################################################

D:\1.embedded\kit\cc2530\Reference\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_csp_tx.c
      3            Revised:        $Date: 2013-05-17 11:08:52 -0700 (Fri, 17 May 2013) $
      4            Revision:       $Revision: 34354 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                           Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9c
   \   unsigned char volatile __sfr T2CSPCFG
   \                     T2CSPCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe1
   \   unsigned char volatile __sfr RFST
   \                     RFST:
   \   000000                DS 1
     48          
     49          /* high-level */
     50          #include "mac_spec.h"
     51          #include "mac_pib.h"
     52          
     53          /* exported low-level */
     54          #include "mac_low_level.h"
     55          
     56          /* low-level specific */
     57          #include "mac_csp_tx.h"
     58          #include "mac_tx.h"
     59          #include "mac_rx.h"
     60          #include "mac_rx_onoff.h"
     61          
     62          /* target specific */
     63          #include "mac_radio_defs.h"
     64          
     65          /* debug */
     66          #include "mac_assert.h"
     67          
     68          /* ------------------------------------------------------------------------------------------------
     69           *                                   CSP Defines / Macros
     70           * ------------------------------------------------------------------------------------------------
     71           */
     72          /* immediate strobe commands */
     73          #define ISSTART     0xE1
     74          #define ISSTOP      0xE2
     75          #define ISCLEAR     0xFF
     76          
     77          /* strobe processor instructions */
     78          #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
     79          #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
     80          #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
     81          #define WEVENT1     (0xB8)                 /* wait for MAC timer compare                          */
     82          #define WAITX       (0xBC)                 /* wait for CSPX number of MAC timer overflows         */
     83          #define LABEL       (0xBB)                 /* set next instruction as start of loop               */
     84          #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
     85          #define INT         (0xBA)                 /* assert IRQ_CSP_INT interrupt                        */
     86          #define INCY        (0xC1)                 /* increment CSPY                                      */
     87          #define INCMAXY(m)  (0xC8 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
     88          #define DECX        (0xC3)                 /* decrement CSPX                                      */
     89          #define DECY        (0xC4)                 /* decrement CSPY                                      */
     90          #define DECZ        (0xC5)                 /* decrement CSPZ                                      */
     91          #define RANDXY      (0xBD)                 /* load the lower CSPY bits of CSPX with random value  */
     92          
     93          /* strobe processor command instructions */
     94          #define SSTOP       (0xD2)    /* stop program execution                                      */
     95          #define SNOP        (0xD0)    /* no operation                                                */
     96          #define STXCAL      (0xDC)    /* enable and calibrate frequency synthesizer for TX           */
     97          #define SRXON       (0xD3)    /* turn on receiver                                            */
     98          #define STXON       (0xD9)    /* transmit after calibration                                  */
     99          #define STXONCCA    (0xDA)    /* transmit after calibration if CCA indicates clear channel   */
    100          #define SRFOFF      (0xDF)    /* turn off RX/TX                                              */
    101          #define SFLUSHRX    (0xDD)    /* flush receive FIFO                                          */
    102          #define SFLUSHTX    (0xDE)    /* flush transmit FIFO                                         */
    103          #define SACK        (0xD6)    /* send ACK frame                                              */
    104          #define SACKPEND    (0xD7)    /* send ACK frame with pending bit set                         */
    105          
    106          /* conditions for use with instructions SKIP and RPT */
    107          #define C_CCA_IS_VALID        0x00
    108          #define C_SFD_IS_ACTIVE       0x01
    109          #define C_CPU_CTRL_IS_ON      0x02
    110          #define C_END_INSTR_MEM       0x03
    111          #define C_CSPX_IS_ZERO        0x04
    112          #define C_CSPY_IS_ZERO        0x05
    113          #define C_CSPZ_IS_ZERO        0x06
    114          #define C_RSSI_IS_VALID       0x07
    115          
    116          /* negated conditions for use with instructions SKIP and RPT */
    117          #define C_NEGATE(c)   ((c) | 0x08)
    118          #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
    119          #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
    120          #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
    121          #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
    122          #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
    123          #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
    124          #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
    125          #define C_RSSI_IS_INVALID     C_NEGATE(C_RSSI_IS_VALID)
    126          
    127          
    128          /* ------------------------------------------------------------------------------------------------
    129           *                                         Defines
    130           * ------------------------------------------------------------------------------------------------
    131           */
    132          
    133          /* CSPZ return values from CSP program */
    134          #define CSPZ_CODE_TX_DONE           0
    135          #define CSPZ_CODE_CHANNEL_BUSY      1
    136          #define CSPZ_CODE_TX_ACK_TIME_OUT   2
    137          
    138          
    139          /* ------------------------------------------------------------------------------------------------
    140           *                                     Local Programs
    141           * ------------------------------------------------------------------------------------------------
    142           */
    143          static void  cspPrepForTxProgram(void);
    144          static void  cspWeventSetTriggerNow(void);
    145          static void  cspWeventSetTriggerSymbols(uint8 symbols);
    146          static uint8 cspReadCountSymbols(void);
    147          
    148          
    149          
    150          /* ------------------------------------------------------------------------------------------------
    151           *                                          Macros
    152           * ------------------------------------------------------------------------------------------------
    153           */
    154          #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP; RFST = ISCLEAR; )
    155          #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
    156          
    157          /*
    158           *  These macros improve readability of using T2CMP in conjunction with WEVENT.
    159           *
    160           *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
    161           *  It is configurable and has been set to compare against the upper byte of the timer value.
    162           *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
    163           *  the value of T2CMP.
    164           *
    165           *  Reading the timer value is done by reading the low byte first.  This latches the
    166           *  high byte.  A trick with the ternary operator is used by a macro below to force a
    167           *  read of the low byte when returning the value of the high byte.
    168           *
    169           *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT1 trigger point at the current timer count
    170           *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT1 trigger point in symbols
    171           *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
    172           */
    173          #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
    174          
    175          #define CSP_WEVENT_CLEAR_TRIGGER()            st( T2IRQF = (TIMER2_COMPARE1F ^ 0xFF); )
    176          #define CSP_WEVENT_SET_TRIGGER_NOW()          cspWeventSetTriggerNow()
    177          #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     cspWeventSetTriggerSymbols(x)
    178          #define CSP_WEVENT_READ_COUNT_SYMBOLS()       cspReadCountSymbols()
    179          
    180          /*
    181           *  Number of bits used for aligning a slotted transmit to the backoff count (plus
    182           *  derived values).  There are restrictions on this value.  Compile time integrity
    183           *  checks will catch an illegal setting of this value.  A full explanation accompanies
    184           *  this compile time check (see bottom of this file).
    185           */
    186          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
    187          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
    188          #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
    189          
    190          
    191          /**************************************************************************************************
    192           * @fn          macCspTxReset
    193           *
    194           * @brief       Reset the CSP.  Immediately halts any running program.
    195           *
    196           * @param       none
    197           *
    198           * @return      none
    199           **************************************************************************************************
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          MAC_INTERNAL_API void macCspTxReset(void)
   \                     macCspTxReset:
    202          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    203            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV     DPTR,#0x61a4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E4         CLR     0xE0 /* A   */.4
   \   00000A   F0           MOVX    @DPTR,A
    204            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   C2E3         CLR     0xE0 /* A   */.3
   \   00000E                REQUIRE ?Subroutine2
   \   00000E                REQUIRE RFST
   \   00000E                ; // Fall through to label ?Subroutine2
    205            CSP_STOP_AND_CLEAR_PROGRAM();
    206          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   75E1E2       MOV     0xe1,#-0x1e
   \   000004   75E1FF       MOV     0xe1,#-0x1
   \   000007   02....       LJMP    ??Subroutine6_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine6_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    207          
    208          
    209          /*=================================================================================================
    210           * @fn          cspWeventSetTriggerNow
    211           *
    212           * @brief       sets the WEVENT1 trigger point at the current timer count
    213           *
    214           * @param       none
    215           *
    216           * @return      symbols
    217           *=================================================================================================
    218           */
    219          static void cspWeventSetTriggerNow(void)
    220          {
    221            halIntState_t  s;
    222            uint8          temp0, temp1;
    223          
    224            /* Clear the compare interrupt flag for debugging purpose. */
    225            CSP_WEVENT_CLEAR_TRIGGER();
    226          
    227            /* copy current timer count to compare */
    228            HAL_ENTER_CRITICAL_SECTION(s);
    229            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    230            temp0 = T2M0;
    231            temp1 = T2M1;
    232          
    233            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    234             * compare = 0 for both the timer and the overflow counter.
    235             */
    236            if ((macChipVersion <= REV_B) && (temp0 == 0) && (temp1 == 0))
    237            {
    238              temp0++;
    239            }
    240          
    241            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    242            T2M0 = temp0;
    243            T2M1 = temp1;
    244            HAL_EXIT_CRITICAL_SECTION(s);
    245          }
    246          
    247          
    248          /*=================================================================================================
    249           * @fn          cspWeventSetTriggerSymbols
    250           *
    251           * @brief       sets the WEVENT1 trigger point in symbols
    252           *
    253           * @param       symbols
    254           *
    255           * @return      none
    256           *=================================================================================================
    257           */
    258          static void cspWeventSetTriggerSymbols(uint8 symbols)
    259          {
    260            halIntState_t  s;
    261            uint16         cmp;
    262          
    263            MAC_ASSERT(symbols <= MAC_A_UNIT_BACKOFF_PERIOD);
    264          
    265            /* Clear the compare interrupt flag for debugging purpose. */
    266            CSP_WEVENT_CLEAR_TRIGGER();
    267          
    268            HAL_ENTER_CRITICAL_SECTION(s);
    269            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    270            cmp  = (symbols) * MAC_RADIO_TIMER_TICKS_PER_SYMBOL();
    271          
    272            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    273             * compare = 0 for both the timer and the overflow counter.
    274             */
    275            if ((macChipVersion <= REV_B) && (cmp == 0))
    276            {
    277              cmp++;
    278            }
    279            T2M0 = (cmp & 0xFF);
    280            T2M1 = (cmp >> 8);
    281            HAL_EXIT_CRITICAL_SECTION(s);
    282          }
    283          
    284          
    285          /*=================================================================================================
    286           * @fn          cspReadCountSymbols
    287           *
    288           * @brief       reads the current timer count in symbols
    289           *
    290           * @param       none
    291           *
    292           * @return      symbols
    293           *=================================================================================================
    294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    295          static uint8 cspReadCountSymbols(void)
   \                     cspReadCountSymbols:
    296          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    297            uint8          countLow, countHigh;
    298            halIntState_t  s;
    299          
    300            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A9A8         MOV     R1,0xa8+0x0
   \   000002   C2AF         CLR     0xa8.7
    301            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000004   75C300       MOV     0xc3,#0x0
    302            countLow  = T2M0;
   \   000007   A8A2         MOV     R0,0xa2+0x0
    303            countHigh = T2M1;
   \   000009   AAA3         MOV     R2,0xa3+0x0
    304            HAL_EXIT_CRITICAL_SECTION(s);
   \   00000B   E9           MOV     A,R1
   \   00000C   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000E   E4           CLR     A
   \   00000F   33           RLC     A
   \   000010   FC           MOV     R4,A
   \   000011   E9           MOV     A,R1
   \   000012   A2E7         MOV     C,0xE0 /* A   */.7
   \   000014   92AF         MOV     0xa8.7,C
    305          
    306            return (((countHigh << 8) | countLow) / MAC_RADIO_TIMER_TICKS_PER_SYMBOL());
   \   000016   E4           CLR     A
   \   000017   CA           XCH     A,R2
   \   000018   F9           MOV     R1,A
   \   000019   7B02         MOV     R3,#0x2
   \   00001B   12....       LCALL   ?S_DIV_MOD
   \   00001E   E8           MOV     A,R0
   \   00001F   F9           MOV     R1,A
   \   000020   02....       LJMP    ?BRET
   \   000023                REQUIRE _A_IEN0
   \   000023                REQUIRE T2MSEL
   \   000023                REQUIRE T2M0
   \   000023                REQUIRE T2M1
    307          }
    308          
    309          
    310          /*=================================================================================================
    311           * @fn          cspPrepForTxProgram
    312           *
    313           * @brief       Prepare and initialize for transmit CSP program.
    314           *              Call *before* loading the CSP program!
    315           *
    316           * @param       none
    317           *
    318           * @return      none
    319           *=================================================================================================
    320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    321          static void cspPrepForTxProgram(void)
   \                     cspPrepForTxProgram:
    322          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    323            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
   \   000004   9061A4       MOV     DPTR,#0x61a4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   A2E4         MOV     C,0xE0 /* A   */.4
   \   00000A   5003         JNC     ??cspPrepForTxProgram_0
   \   00000C                ; Setup parameters for call to function halAssertHandler
   \   00000C   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    324          
    325            /* set CSP EVENT1 to T2 CMP1 */
    326            MAC_MCU_CONFIG_CSP_EVENT1();
   \                     ??cspPrepForTxProgram_0:
   \   00000F   759C01       MOV     0x9c,#0x1
    327          
    328            /* set up parameters for CSP transmit program */
    329            CSPZ = CSPZ_CODE_CHANNEL_BUSY;
   \   000012   9061E4       MOV     DPTR,#0x61e4
   \   000015   7401         MOV     A,#0x1
   \   000017   F0           MOVX    @DPTR,A
    330          
    331            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    332            CSP_STOP_AND_CLEAR_PROGRAM();
   \   000018   75E1E2       MOV     0xe1,#-0x1e
   \   00001B   75E1FF       MOV     0xe1,#-0x1
    333            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
   \   00001E   A8A8         MOV     R0,0xa8+0x0
   \   000020   C2AF         CLR     0xa8.7
   \   000022   759B00       MOV     0x9b,#0x0
   \   000025   7591EF       MOV     0x91,#-0x11
   \   000028   E8           MOV     A,R0
   \   000029   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002B   E4           CLR     A
   \   00002C   33           RLC     A
   \   00002D   FA           MOV     R2,A
   \   00002E   E8           MOV     A,R0
   \   00002F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000031   92AF         MOV     0xa8.7,C
    334            MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
   \   000033   A9A8         MOV     R1,0xa8+0x0
   \   000035   C2AF         CLR     0xa8.7
   \   000037   759B00       MOV     0x9b,#0x0
   \   00003A   7591F7       MOV     0x91,#-0x9
   \   00003D   E9           MOV     A,R1
   \   00003E   A2E7         MOV     C,0xE0 /* A   */.7
   \   000040   E4           CLR     A
   \   000041   33           RLC     A
   \   000042   F8           MOV     R0,A
   \   000043   E9           MOV     A,R1
   \   000044   A2E7         MOV     C,0xE0 /* A   */.7
   \   000046   92AF         MOV     0xa8.7,C
    335          }
   \   000048   02....       LJMP    ??Subroutine6_0 & 0xFFFF
   \   00004B                REQUIRE T2CSPCFG
   \   00004B                REQUIRE RFST
   \   00004B                REQUIRE _A_IEN0
   \   00004B                REQUIRE S1CON
   \   00004B                REQUIRE RFIRQF1
    336          
    337          
    338          /**************************************************************************************************
    339           * @fn          macCspTxPrepCsmaUnslotted
    340           *
    341           * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
    342           *
    343           * @param       none
    344           *
    345           * @return      none
    346           **************************************************************************************************
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          MAC_INTERNAL_API void macCspTxPrepCsmaUnslotted(void)
   \                     macCspTxPrepCsmaUnslotted:
    349          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    350            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
    351          
    352            /*----------------------------------------------------------------------
    353             *  Load CSP program :  Unslotted CSMA transmit
    354             */
    355          
    356            /*
    357             *  Wait for X number of backoffs, then wait for intra-backoff count
    358             *  to reach value set for WEVENT1.
    359             */
    360            RFST = WAITX;
   \   000007   75E1BC       MOV     0xe1,#-0x44
    361            RFST = WEVENT1;
   \   00000A   75E1B8       MOV     0xe1,#-0x48
    362          
    363            /* wait until RSSI is valid */
    364            RFST = WHILE(C_RSSI_IS_INVALID);
   \   00000D   75E10F       MOV     0xe1,#0xf
    365          
    366            /* Note that the CCA signal is updated four clock cycles (system clock) 
    367             * after the RSSI_VALID signal has been set.
    368             */
    369            RFST = SNOP;
   \   000010   75E1D0       MOV     0xe1,#-0x30
    370            RFST = SNOP;
   \   000013   75E1D0       MOV     0xe1,#-0x30
    371            RFST = SNOP;
   \   000016   75E1D0       MOV     0xe1,#-0x30
    372            RFST = SNOP;
   \   000019   75E1D0       MOV     0xe1,#-0x30
    373          
    374            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    375            RFST = SKIP(1, C_CCA_IS_VALID);
   \   00001C   80..         SJMP    ?Subroutine0
   \   00001E                REQUIRE RFST
    376            RFST = SSTOP;
    377          
    378            /* CSMA has passed so transmit (actual frame starts one backoff from when strobe is sent) */
    379            RFST = STXON;
    380          
    381            /*
    382             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    383             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    384             *  though, is not certain.  For bulletproof operation, the first step is to wait
    385             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    386             *  for it to go active.
    387             */
    388            RFST = WHILE(C_SFD_IS_ACTIVE);
    389            RFST = WHILE(C_SFD_IS_INACTIVE);
    390          
    391            /*
    392             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    393             *  The ISR for this interrupt records the timestamp (which was just captured
    394             *  when SFD went high).
    395             */
    396            RFST = INT;
    397          
    398            /*
    399             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    400             *  the transmit was successful.
    401             */
    402            RFST = WHILE(C_SFD_IS_ACTIVE);
    403            RFST = DECZ;
    404          
    405            /*
    406             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    407             */
    408            RFST = SSTOP;
    409          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   75E110       MOV     0xe1,#0x10
   \   000003   75E1D2       MOV     0xe1,#-0x2e
   \   000006                REQUIRE ??Subroutine4_0
   \   000006                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   75E1D9       MOV     0xe1,#-0x27
   \   000003   75E101       MOV     0xe1,#0x1
   \   000006   75E109       MOV     0xe1,#0x9
   \   000009   75E1BA       MOV     0xe1,#-0x46
   \   00000C   75E101       MOV     0xe1,#0x1
   \   00000F                REQUIRE ??Subroutine5_0
   \   00000F                ; // Fall through to label ??Subroutine5_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   75E1C5       MOV     0xe1,#-0x3b
   \   000003   75E1D2       MOV     0xe1,#-0x2e
   \   000006                REQUIRE ??Subroutine6_0
   \   000006                ; // Fall through to label ??Subroutine6_0
    410          
    411          
    412          /**************************************************************************************************
    413           * @fn          macCspTxPrepCsmaSlotted
    414           *
    415           * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
    416           *
    417           * @param       none
    418           *
    419           * @return      none
    420           **************************************************************************************************
    421           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    422          MAC_INTERNAL_API void macCspTxPrepCsmaSlotted(void)
   \                     macCspTxPrepCsmaSlotted:
    423          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    424            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
    425          
    426            /*----------------------------------------------------------------------
    427             *  Load CSP program :  Slotted CSMA transmit
    428             */
    429          
    430            /* wait for X number of backoffs */
    431            RFST = WAITX;
   \   000007   75E1BC       MOV     0xe1,#-0x44
    432            
    433            /* sample RSSI, if it is valid then skip one extra backoff. */
    434            RFST = SKIP(1, C_RSSI_IS_VALID);
   \   00000A   75E117       MOV     0xe1,#0x17
    435            
    436            /* wait for one backoff to guarantee receiver has been on at least that long */
    437            RFST = WAITW(1);
   \   00000D   75E181       MOV     0xe1,#-0x7f
    438          
    439            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    440            RFST = SKIP(1, C_CCA_IS_VALID);
   \   000010   75E110       MOV     0xe1,#0x10
    441            RFST = SSTOP;
   \   000013   75E1D2       MOV     0xe1,#-0x2e
    442          
    443            /* per slotted CSMA-CCA in specification, wait one backoff */
    444            RFST = WAITW(1);
   \   000016   75E181       MOV     0xe1,#-0x7f
    445          
    446            /* sample CCA again, if it fails exit from here, CSPZ indicates result */
    447            RFST = SKIP(1, C_CCA_IS_VALID);
   \   000019   80..         SJMP    ?Subroutine0
   \   00001B                REQUIRE RFST
    448            RFST = SSTOP;
    449          
    450            /* CSMA has passed so transmit */
    451            RFST = STXON;
    452          
    453            /*
    454             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    455             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    456             *  though, is not certain.  For bulletproof operation, the first step is to wait
    457             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    458             *  for it to go active.
    459             */
    460            RFST = WHILE(C_SFD_IS_ACTIVE);
    461            RFST = WHILE(C_SFD_IS_INACTIVE);
    462          
    463            /*
    464             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    465             *  The ISR for this interrupt records the timestamp (which was just captured
    466             *  when SFD went high).
    467             */
    468            RFST = INT;
    469          
    470            /*
    471             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    472             *  the transmit was successful.
    473             */
    474            RFST = WHILE(C_SFD_IS_ACTIVE);
    475            RFST = DECZ;
    476          
    477            /*
    478             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    479             */
    480            RFST = SSTOP;
    481          }
    482          
    483          
    484          /**************************************************************************************************
    485           * @fn          macCspTxGoCsma
    486           *
    487           * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
    488           *              slotted or unslotted CSMA transmits.  When CSP program has finished,
    489           *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
    490           *              turn call macTxDoneCallback().
    491           *
    492           * @param       none
    493           *
    494           * @return      none
    495           **************************************************************************************************
    496           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    497          MAC_INTERNAL_API void macCspTxGoCsma(void)
   \                     macCspTxGoCsma:
    498          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    499            /*
    500             *  Set CSPX with the countdown time of the CSMA delay.
    501             */
    502            CSPX = macTxCsmaBackoffDelay;
   \   000004   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   000007   E0           MOVX    A,@DPTR
   \   000008   9061E2       MOV     DPTR,#0x61e2
   \   00000B   F0           MOVX    @DPTR,A
    503          
    504            /*
    505             *  Set WEVENT to trigger at the current value of the timer.  This allows
    506             *  unslotted CSMA to transmit just a little bit sooner.
    507             */
    508            CSP_WEVENT_SET_TRIGGER_NOW();
   \   00000C   75A1FD       MOV     0xa1,#-0x3
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   33           RLC     A
   \   000013   FA           MOV     R2,A
   \   000014   C2AF         CLR     0xa8.7
   \   000016   75C300       MOV     0xc3,#0x0
   \   000019   A8A2         MOV     R0,0xa2+0x0
   \   00001B   A9A3         MOV     R1,0xa3+0x0
   \   00001D   90....       MOV     DPTR,#macChipVersion
   \   000020   E0           MOVX    A,@DPTR
   \   000021   9412         SUBB    A,#0x12
   \   000023   5008         JNC     ??macCspTxGoCsma_0
   \   000025   E8           MOV     A,R0
   \   000026   7005         JNZ     ??macCspTxGoCsma_0
   \   000028   E9           MOV     A,R1
   \   000029   7002         JNZ     ??macCspTxGoCsma_0
   \   00002B   7801         MOV     R0,#0x1
   \                     ??macCspTxGoCsma_0:
   \   00002D   75C303       MOV     0xc3,#0x3
   \   000030   88A2         MOV     0xa2,R0
   \   000032   89A3         MOV     0xa3,R1
   \   000034   EA           MOV     A,R2
   \   000035   A2E0         MOV     C,0xE0 /* A   */.0
   \   000037   92AF         MOV     0xa8.7,C
    509          
    510            /*
    511             *  Enable interrupt that fires when CSP program stops.
    512             *  Also enable interrupt that fires when INT instruction
    513             *  is executed.
    514             */
    515            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   000039                REQUIRE ?Subroutine1
   \   000039                REQUIRE RFST
   \   000039                REQUIRE T2IRQF
   \   000039                REQUIRE _A_IEN0
   \   000039                REQUIRE T2MSEL
   \   000039                REQUIRE T2M0
   \   000039                REQUIRE T2M1
   \   000039                ; // Fall through to label ?Subroutine1
    516            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    517          
    518            /*
    519             *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
    520             *  least one backoff before performing clear channel assessment (CCA).
    521             */
    522            macRxOn();
    523          
    524            /* start the CSP program */
    525            CSP_START_PROGRAM();
    526          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000003                ; Setup parameters for call to function macRxOn
   \   000003                ; Setup parameters for call to function macRxOn
   \   000003   12....       LCALL   `??macRxOn::?relay`  ; Banked call to: macRxOn
   \   000006   75E1E1       MOV     0xe1,#-0x1f
   \   000009   80..         SJMP    ??Subroutine6_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   9061A4       MOV     DPTR,#0x61a4
   \   000003   E0           MOVX    A,@DPTR
   \   000004   D2E4         SETB    0xE0 /* A   */.4
   \   000006   F0           MOVX    @DPTR,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E3         SETB    0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET
    527          
    528          
    529          /**************************************************************************************************
    530           * @fn          macCspTxPrepSlotted
    531           *
    532           * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
    533           *              Load CSP program and set CSP parameters.
    534           *
    535           * @param       none
    536           *
    537           * @return      none
    538           **************************************************************************************************
    539           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    540          MAC_INTERNAL_API void macCspTxPrepSlotted(void)
   \                     macCspTxPrepSlotted:
    541          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    542            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
    543          
    544            /*----------------------------------------------------------------------
    545             *  Load CSP program :  Slotted transmit (no CSMA)
    546             */
    547          
    548            /* wait for X number of backoffs */
    549            RFST = WAITX;
   \   000007   75E1BC       MOV     0xe1,#-0x44
    550          
    551            /* just transmit, no CSMA required */
    552            RFST = STXON;
   \   00000A   80..         SJMP    ??Subroutine4_0
   \   00000C                REQUIRE RFST
    553          
    554            /*
    555             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    556             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    557             *  though, is not certain.  For bulletproof operation, the first step is to wait
    558             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    559             *  for it to go active.
    560             */
    561            RFST = WHILE(C_SFD_IS_ACTIVE);
    562            RFST = WHILE(C_SFD_IS_INACTIVE);
    563          
    564            /*
    565             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    566             *  The ISR for this interrupt records the timestamp (which was just captured
    567             *  when SFD went high).
    568             */
    569            RFST = INT;
    570          
    571            /*
    572             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    573             *  the transmit was successful.
    574             */
    575            RFST = WHILE(C_SFD_IS_ACTIVE);
    576            RFST = DECZ;
    577          
    578            /*
    579             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    580             */
    581            RFST = SSTOP;
    582          
    583          }
    584          
    585          
    586          /**************************************************************************************************
    587           * @fn          macCspTxGoSlotted
    588           *
    589           * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
    590           *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
    591           *              This ISR will in turn call macTxDoneCallback().
    592           *
    593           * @param       none
    594           *
    595           * @return      none
    596           **************************************************************************************************
    597           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    598          MAC_INTERNAL_API void macCspTxGoSlotted(void)
   \                     macCspTxGoSlotted:
    599          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    600            halIntState_t  s;
    601            uint8 lowByteOfBackoffCount;
    602            uint8 backoffCountdown;
    603          
    604            /*
    605             *  Enable interrupt that fires when CSP program stops.
    606             *  Also enable interrupt that fires when INT instruction
    607             *  is executed.
    608             */
    609            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   000005   12....       LCALL   ?Subroutine3 & 0xFFFF
    610            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    611          
    612            /* critical section needed for timer accesses */
    613            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??CrossCallReturnLabel_1:
   \   000008   A2AF         MOV     C,0xa8.7
   \   00000A   E4           CLR     A
   \   00000B   33           RLC     A
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   C2AF         CLR     0xa8.7
    614          
    615            /* store lowest byte of backoff count (same as lowest byte of overflow count) */
    616            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000010   75C300       MOV     0xc3,#0x0
    617          
    618            /* Latch T2MOVFx */
    619            T2M0;
   \   000013   E5A2         MOV     A,0xa2
    620            lowByteOfBackoffCount = T2MOVF0;
   \   000015   AFA4         MOV     R7,0xa4+0x0
    621          
    622            /*
    623             *  Compute the number of backoffs until time to strobe transmit.  The strobe should
    624             *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
    625             *  countdown value is to determine when the lower bits would rollover and become zero,
    626             *  and then subtract one.
    627             */
    628            backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
   \   000017   740F         MOV     A,#0xf
   \   000019   5F           ANL     A,R7
   \   00001A   F8           MOV     R0,A
   \   00001B   740F         MOV     A,#0xf
   \   00001D   98           SUBB    A,R0
   \   00001E   FE           MOV     R6,A
    629          
    630            /*
    631             *  Store backoff countdown value into CSPX.
    632             *
    633             *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
    634             *  CSP program will immediately continue if CSPX is zero when executed.  However,
    635             *  if the countdown is zero, it means the transmit function was not called early
    636             *  enough for a properly timed slotted transmit.  The transmit will be late.
    637             */
    638            CSPX = backoffCountdown;
   \   00001F   9061E2       MOV     DPTR,#0x61e2
   \   000022   F0           MOVX    @DPTR,A
    639          
    640            /* Disable Rx and flush RXFIFO due to chip bug #1546 */
    641            macRxHardDisable();
   \   000023                ; Setup parameters for call to function macRxHardDisable
   \   000023   12....       LCALL   `??macRxHardDisable::?relay`; Banked call to: macRxHardDisable
    642          
    643            /*
    644             *  The receiver will be turned on during CSP execution, guaranteed.
    645             *  Since it is not possible to update C variables within the CSP,
    646             *  the new "on" state of the receiver must be set a little early
    647             *  here before the CSP is started.
    648             */
    649            MAC_RX_WAS_FORCED_ON();
   \   000026   90....       MOV     DPTR,#macRxOnFlag
   \   000029   7401         MOV     A,#0x1
   \   00002B   F0           MOVX    @DPTR,A
    650          
    651            /* start the CSP program */
    652            CSP_START_PROGRAM();
   \   00002C   75E1E1       MOV     0xe1,#-0x1f
    653          
    654            /*
    655             *  If the previous stored low byte of the backoff count is no longer equal to
    656             *  the current value, a rollover has occurred.  This means the backoff countdown
    657             *  stored in CSPX may not be correct.
    658             *
    659             *  In this case, the value of CSPX is reloaded to reflect the correct backoff
    660             *  countdown value (this is one less than what was just used as a rollover has
    661             *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
    662             *  of another rollover occurring.  This means the value written to CSPX is guaranteed
    663             *  to be accurate.
    664             *
    665             *  Also, the logic below ensures that the value written to CSPX is at least one.
    666             *  This is needed for correct operation of the WAITX instruction.  As with an
    667             *  initial backoff countdown value of zero, if this case does occur, it means the
    668             *  transmit function was not called early enough for a properly timed slotted transmit.
    669             *  The transmit will be late.
    670             *
    671             *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
    672             *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
    673             *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
    674             *  collision is not possible (still within a critical section here too).
    675             */
    676            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00002F   75C300       MOV     0xc3,#0x0
    677          
    678            /* Latch T2MOVFx */
    679            T2M0;
   \   000032   E5A2         MOV     A,0xa2
    680            if ((lowByteOfBackoffCount != T2MOVF0) && (backoffCountdown > 1))
   \   000034   E5A4         MOV     A,0xa4
   \   000036   6F           XRL     A,R7
   \   000037   600D         JZ      ??macCspTxGoSlotted_0
   \   000039   EE           MOV     A,R6
   \   00003A   C3           CLR     C
   \   00003B   9402         SUBB    A,#0x2
   \   00003D   4007         JC      ??macCspTxGoSlotted_0
    681            {
    682              CSPX = backoffCountdown - 1;
   \   00003F   74FF         MOV     A,#-0x1
   \   000041   2E           ADD     A,R6
   \   000042   9061E2       MOV     DPTR,#0x61e2
   \   000045   F0           MOVX    @DPTR,A
    683            }
    684          
    685            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macCspTxGoSlotted_0:
   \   000046   E5..         MOV     A,?V0
   \   000048   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004A   92AF         MOV     0xa8.7,C
    686          }
   \   00004C   7F01         MOV     R7,#0x1
   \   00004E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000051                REQUIRE _A_IEN0
   \   000051                REQUIRE T2MSEL
   \   000051                REQUIRE T2M0
   \   000051                REQUIRE T2MOVF0
   \   000051                REQUIRE RFST
    687          
    688          
    689          /**************************************************************************************************
    690           * @fn          macCspTxPrepGreenPower
    691           *
    692           * @brief       Prepare CSP for "Green Power" transmit.  Load CSP program and set CSP parameters.
    693           *
    694           * @param       none
    695           *
    696           * @return      none
    697           **************************************************************************************************
    698           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    699          MAC_INTERNAL_API void macCspTxPrepGreenPower(void)
   \                     macCspTxPrepGreenPower:
    700          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    701            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL   `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
    702          
    703            /*----------------------------------------------------------------------
    704             *  Load CSP program :  Green Power transmit
    705             */
    706            
    707            /* Set the next STXON as a lable */
    708            RFST = LABEL;
   \   000007   75E1BB       MOV     0xe1,#-0x45
    709            
    710            /* wait for number of backoffs for interframe spacing */
    711            RFST = WAITW(macTxGpInterframeDelay);
   \   00000A   90....       MOV     DPTR,#macTxGpInterframeDelay
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   541F         ANL     A,#0x1f
   \   000010   4480         ORL     A,#0x80
   \   000012   F5E1         MOV     0xe1,A
    712            
    713            /* Transmit (actual frame starts one backoff from when strobe is sent) */
    714            RFST = STXON;
   \   000014   75E1D9       MOV     0xe1,#-0x27
    715          
    716            /*
    717             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    718             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    719             *  though, is not certain.  For bulletproof operation, the first step is to wait
    720             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    721             *  for it to go active.
    722             */
    723            RFST = WHILE(C_SFD_IS_ACTIVE);
   \   000017   75E101       MOV     0xe1,#0x1
    724            RFST = WHILE(C_SFD_IS_INACTIVE);
   \   00001A   75E109       MOV     0xe1,#0x9
    725          
    726            /*
    727             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    728             *  The ISR for this interrupt records the timestamp (which was just captured
    729             *  when SFD went high).
    730             */
    731            RFST = INT;
   \   00001D   75E1BA       MOV     0xe1,#-0x46
    732          
    733            /*
    734             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    735             *  the transmit was successful.
    736             */
    737            RFST = WHILE(C_SFD_IS_ACTIVE);
   \   000020   75E101       MOV     0xe1,#0x1
    738            RFST = DECX;
   \   000023   75E1C3       MOV     0xe1,#-0x3d
    739          
    740            /* Go to the STXON label for repeat transmissions */
    741            RFST = RPT(C_CSPX_IS_NON_ZERO);
   \   000026   75E1AC       MOV     0xe1,#-0x54
    742            
    743            /* Clear the busy status */
    744            RFST = DECZ;
   \   000029   02....       LJMP    ??Subroutine5_0 & 0xFFFF
   \   00002C                REQUIRE RFST
    745            
    746            /*
    747             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    748             */
    749            RFST = SSTOP;
    750          }
    751          
    752          
    753          /**************************************************************************************************
    754           * @fn          macCspTxGoGreenPower
    755           *
    756           * @brief       Run previously loaded CSP program for Green Power transmit.  When CSP program 
    757           *              has finished, an interrupt occurs and macCspTxStopIsr() is called.  This ISR 
    758           *              will in turn call macTxDoneCallback().
    759           *
    760           * @param       none
    761           *
    762           * @return      none
    763           **************************************************************************************************
    764           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    765          MAC_INTERNAL_API void macCspTxGoGreenPower(void)
   \                     macCspTxGoGreenPower:
    766          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    767            /*
    768             *  Set CSPX with the countdown of number of Green Power transmissions.
    769             */
    770            CSPX = macTxCsmaBackoffDelay;
   \   000004   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   000007   E0           MOVX    A,@DPTR
   \   000008   9061E2       MOV     DPTR,#0x61e2
   \   00000B   F0           MOVX    @DPTR,A
    771          
    772            /*
    773             *  Enable interrupt that fires when CSP program stops.
    774             *  Also enable interrupt that fires when INT instruction
    775             *  is executed.
    776             */
    777            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   00000C   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00000F                REQUIRE RFST
    778            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    779          
    780            /*
    781             *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
    782             *  least one backoff before performing clear channel assessment (CCA).
    783             */
    784            macRxOn();
    785          
    786            /* start the CSP program */
    787            CSP_START_PROGRAM();
    788          }
    789          
    790          
    791          /**************************************************************************************************
    792           * @fn          macCspForceTxDoneIfPending
    793           *
    794           * @brief       The function clears out any pending TX done logic.  Used by receive logic
    795           *              to make sure its ISR does not prevent transmit from completing in a reasonable
    796           *              amount of time.
    797           *
    798           * @param       none
    799           *
    800           * @return      none
    801           **************************************************************************************************
    802           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    803          MAC_INTERNAL_API void macCspForceTxDoneIfPending(void)
   \                     macCspForceTxDoneIfPending:
    804          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    805            if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
   \   000004   9061E4       MOV     DPTR,#0x61e4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7017         JNZ     ??macCspForceTxDoneIfPending_0
   \   00000A   9061A4       MOV     DPTR,#0x61a4
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   A2E4         MOV     C,0xE0 /* A   */.4
   \   000010   500F         JNC     ??macCspForceTxDoneIfPending_0
    806            {
    807              MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000012   E0           MOVX    A,@DPTR
   \   000013   C2E4         CLR     0xE0 /* A   */.4
   \   000015   F0           MOVX    @DPTR,A
    808              if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E3         MOV     C,0xE0 /* A   */.3
   \   000019   5003         JNC     ??macCspForceTxDoneIfPending_1
    809              {
    810                macCspTxIntIsr();
   \   00001B                ; Setup parameters for call to function macCspTxIntIsr
   \   00001B   12....       LCALL   `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
    811              }
    812              macTxDoneCallback();
   \                     ??macCspForceTxDoneIfPending_1:
   \   00001E                ; Setup parameters for call to function macTxDoneCallback
   \   00001E   12....       LCALL   `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
    813            }
    814          }
   \                     ??macCspForceTxDoneIfPending_0:
   \   000021   02....       LJMP    ??Subroutine6_0 & 0xFFFF
    815          
    816          
    817          /**************************************************************************************************
    818           * @fn          macCspTxRequestAckTimeoutCallback
    819           *
    820           * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
    821           *              the function macCspTxStopIsr() is called via an interrupt.
    822           *
    823           * @param       none
    824           *
    825           * @return      none
    826           **************************************************************************************************
    827           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    828          MAC_INTERNAL_API void macCspTxRequestAckTimeoutCallback(void)
   \                     macCspTxRequestAckTimeoutCallback:
    829          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    830            uint8 startSymbol;
    831            uint8 symbols;
    832            uint8 rollovers;
    833          
    834            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
   \   000005   9061A4       MOV     DPTR,#0x61a4
   \   000008   E0           MOVX    A,@DPTR
   \   000009   A2E4         MOV     C,0xE0 /* A   */.4
   \   00000B   5003         JNC     ??macCspTxRequestAckTimeoutCallback_0
   \   00000D                ; Setup parameters for call to function halAssertHandler
   \   00000D   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    835          
    836            /* record current symbol count */
    837            startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
   \                     ??macCspTxRequestAckTimeoutCallback_0:
   \   000010                ; Setup parameters for call to function cspReadCountSymbols
   \   000010   12....       LCALL   `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
   \   000013   E9           MOV     A,R1
   \   000014   F5..         MOV     ?V2,A
    838          
    839            /* set symbol timeout from PIB */
    840            symbols = macPib.ackWaitDuration;
   \   000016   90....       MOV     DPTR,#macPib
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FE           MOV     R6,A
    841          
    842            /* make sure delay value is not too small for logic to handle */
    843            MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
   \   00001B   C3           CLR     C
   \   00001C   9415         SUBB    A,#0x15
   \   00001E   5003         JNC     ??macCspTxRequestAckTimeoutCallback_1
   \   000020                ; Setup parameters for call to function halAssertHandler
   \   000020   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    844          
    845            /* subtract out symbols left in current backoff period */
    846            symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
   \                     ??macCspTxRequestAckTimeoutCallback_1:
   \   000023   74EC         MOV     A,#-0x14
   \   000025   25..         ADD     A,?V2
   \   000027   2E           ADD     A,R6
   \   000028   FE           MOV     R6,A
    847          
    848            /* calculate rollovers needed for remaining symbols */
    849            rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
   \   000029   75F014       MOV     B,#0x14
   \   00002C   84           DIV     AB
   \   00002D   FF           MOV     R7,A
    850          
    851            /* calculate symbols that still need counted after last rollover */
    852            symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
   \   00002E   75F014       MOV     B,#0x14
   \   000031   A4           MUL     AB
   \   000032   CE           XCH     A,R6
   \   000033   9E           SUBB    A,R6
   \   000034   FE           MOV     R6,A
    853          
    854            /* add one to rollovers to account for symbols remaining in the current backoff period */
    855            rollovers++;
   \   000035   0F           INC     R7
    856          
    857            /* set up parameters for CSP program */
    858            CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
   \   000036   9061E4       MOV     DPTR,#0x61e4
   \   000039   7402         MOV     A,#0x2
   \   00003B   F0           MOVX    @DPTR,A
    859            CSPX = rollovers;
   \   00003C   EF           MOV     A,R7
   \   00003D   9061E2       MOV     DPTR,#0x61e2
   \   000040   F0           MOVX    @DPTR,A
    860            CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
   \   000041   EE           MOV     A,R6
   \   000042   C3           CLR     C
   \   000043   9415         SUBB    A,#0x15
   \   000045   4003         JC      ??macCspTxRequestAckTimeoutCallback_2
   \   000047                ; Setup parameters for call to function halAssertHandler
   \   000047   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
   \                     ??macCspTxRequestAckTimeoutCallback_2:
   \   00004A   75A1FD       MOV     0xa1,#-0x3
   \   00004D   A2AF         MOV     C,0xa8.7
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   FA           MOV     R2,A
   \   000052   C2AF         CLR     0xa8.7
   \   000054   75C303       MOV     0xc3,#0x3
   \   000057   8E..         MOV     ?V0,R6
   \   000059   75..00       MOV     ?V1,#0x0
   \   00005C   7409         MOV     A,#0x9
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?S_SHL
   \   000063   F8           MOV     R0,A
   \   000064   A9..         MOV     R1,?V1
   \   000066   90....       MOV     DPTR,#macChipVersion
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   C3           CLR     C
   \   00006B   9412         SUBB    A,#0x12
   \   00006D   5006         JNC     ??macCspTxRequestAckTimeoutCallback_3
   \   00006F   E9           MOV     A,R1
   \   000070   7003         JNZ     ??macCspTxRequestAckTimeoutCallback_3
   \   000072   08           INC     R0
   \   000073   7900         MOV     R1,#0x0
   \                     ??macCspTxRequestAckTimeoutCallback_3:
   \   000075   E8           MOV     A,R0
   \   000076   F5A2         MOV     0xa2,A
   \   000078   E9           MOV     A,R1
   \   000079   F5A3         MOV     0xa3,A
   \   00007B   EA           MOV     A,R2
   \   00007C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00007E   92AF         MOV     0xa8.7,C
    861          
    862            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    863            CSP_STOP_AND_CLEAR_PROGRAM();
   \   000080   75E1E2       MOV     0xe1,#-0x1e
   \   000083   75E1FF       MOV     0xe1,#-0x1
    864            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
   \   000086   A8A8         MOV     R0,0xa8+0x0
   \   000088   C2AF         CLR     0xa8.7
   \   00008A   759B00       MOV     0x9b,#0x0
   \   00008D   7591EF       MOV     0x91,#-0x11
   \   000090   E8           MOV     A,R0
   \   000091   A2E7         MOV     C,0xE0 /* A   */.7
   \   000093   E4           CLR     A
   \   000094   33           RLC     A
   \   000095   FE           MOV     R6,A
   \   000096   E8           MOV     A,R0
   \   000097   A2E7         MOV     C,0xE0 /* A   */.7
   \   000099   92AF         MOV     0xa8.7,C
    865          
    866            /*--------------------------
    867             * load CSP program
    868             */
    869            RFST = WAITX;
   \   00009B   75E1BC       MOV     0xe1,#-0x44
    870            RFST = WEVENT1;
   \   00009E   75E1B8       MOV     0xe1,#-0x48
    871            RFST = SSTOP;
   \   0000A1   75E1D2       MOV     0xe1,#-0x2e
    872          
    873            /*--------------------------
    874             */
    875          
    876            /* run CSP program */
    877            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   0000A4   9061A4       MOV     DPTR,#0x61a4
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   D2E4         SETB    0xE0 /* A   */.4
   \   0000AA   F0           MOVX    @DPTR,A
    878            CSP_START_PROGRAM();
   \   0000AB   75E1E1       MOV     0xe1,#-0x1f
    879          
    880            /*
    881             *  For bullet proof operation, must account for the boundary condition
    882             *  where a rollover occurs after count was read but before CSP program
    883             *  was started.
    884             *
    885             *  If current symbol count is less that the symbol count recorded at the
    886             *  start of this function, a rollover has occurred.
    887             */
    888            if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
   \   0000AE                ; Setup parameters for call to function cspReadCountSymbols
   \   0000AE   12....       LCALL   `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
   \   0000B1   E9           MOV     A,R1
   \   0000B2   C3           CLR     C
   \   0000B3   95..         SUBB    A,?V2
   \   0000B5   500A         JNC     ??macCspTxRequestAckTimeoutCallback_4
    889            {
    890              /* a rollover has occurred, make sure it was accounted for */
    891              if (CSPX == rollovers)
   \   0000B7   9061E2       MOV     DPTR,#0x61e2
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   6F           XRL     A,R7
   \   0000BC   7003         JNZ     ??macCspTxRequestAckTimeoutCallback_4
    892              {
    893                /*
    894                 *  Rollover event missed, manually decrement CSPX to adjust.
    895                 *
    896                 *  Note : there is a very small chance that CSPX does not
    897                 *  get decremented.  This would occur if CSPX were written
    898                 *  at exactly the same time a timer overflow is occurring (which
    899                 *  causes the CSP instruction WAITX to decrement CSPX).  This
    900                 *  would be extremely rare, but if it does happen, the only
    901                 *  consequence is that the ACK timeout period is extended
    902                 *  by one backoff.
    903                 */
    904                CSPX--;
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   14           DEC     A
   \   0000C0   F0           MOVX    @DPTR,A
    905              }
    906            }
    907          }
   \                     ??macCspTxRequestAckTimeoutCallback_4:
   \   0000C1   7F03         MOV     R7,#0x3
   \   0000C3   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000C6                REQUIRE RFST
   \   0000C6                REQUIRE _A_IEN0
   \   0000C6                REQUIRE S1CON
   \   0000C6                REQUIRE RFIRQF1
   \   0000C6                REQUIRE T2IRQF
   \   0000C6                REQUIRE T2MSEL
   \   0000C6                REQUIRE T2M0
   \   0000C6                REQUIRE T2M1
    908          
    909          
    910          /**************************************************************************************************
    911           * @fn          macCspTxCancelAckTimeoutCallback
    912           *
    913           * @brief       Cancels previous request for ACK timeout callback.
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           **************************************************************************************************
    919           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    920          MAC_INTERNAL_API void macCspTxCancelAckTimeoutCallback(void)
   \                     macCspTxCancelAckTimeoutCallback:
    921          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    922            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV     DPTR,#0x61a4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E4         CLR     0xE0 /* A   */.4
   \   00000A   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   00000D                REQUIRE RFST
    923            CSP_STOP_AND_CLEAR_PROGRAM();
    924          }
    925          
    926          
    927          /**************************************************************************************************
    928           * @fn          macCspTxIntIsr
    929           *
    930           * @brief       Interrupt service routine for handling INT type interrupts from CSP.
    931           *              This interrupt happens when the CSP instruction INT is executed.  It occurs
    932           *              once the SFD signal goes high indicating that transmit has successfully
    933           *              started.  The timer value has been captured at this point and timestamp
    934           *              can be stored.
    935           *
    936           * @param       none
    937           *
    938           * @return      none
    939           **************************************************************************************************
    940           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    941          MAC_INTERNAL_API void macCspTxIntIsr(void)
   \                     macCspTxIntIsr:
    942          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    943            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV     DPTR,#0x61a4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E3         CLR     0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    944          
    945            /* execute callback function that records transmit timestamp */
    946            macTxTimestampCallback();
   \   00000B                ; Setup parameters for call to function macTxTimestampCallback
   \   00000B   12....       LCALL   `??macTxTimestampCallback::?relay`; Banked call to: macTxTimestampCallback
    947          }
   \   00000E   02....       LJMP    ??Subroutine6_0 & 0xFFFF
    948          
    949          
    950          /**************************************************************************************************
    951           * @fn          macCspTxStopIsr
    952           *
    953           * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
    954           *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
    955           *              program, 2) executing SSTOP within the program, 3) executing immediate
    956           *              instruction ISSTOP.
    957           *
    958           *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
    959           *              is the end of a transmit.
    960           *
    961           * @param       none
    962           *
    963           * @return      none
    964           **************************************************************************************************
    965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    966          MAC_INTERNAL_API void macCspTxStopIsr(void)
   \                     macCspTxStopIsr:
    967          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    968            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV     DPTR,#0x61a4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E4         CLR     0xE0 /* A   */.4
   \   00000A   F0           MOVX    @DPTR,A
    969          
    970            if (CSPZ == CSPZ_CODE_TX_DONE)
   \   00000B   9061E4       MOV     DPTR,#0x61e4
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7005         JNZ     ??macCspTxStopIsr_0
    971            {
    972              macTxDoneCallback();
   \   000011                ; Setup parameters for call to function macTxDoneCallback
   \   000011   12....       LCALL   `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
   \   000014   8015         SJMP    ??macCspTxStopIsr_1
    973            }
    974            else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
   \                     ??macCspTxStopIsr_0:
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6401         XRL     A,#0x1
   \   000019   7005         JNZ     ??macCspTxStopIsr_2
    975            {
    976              macTxChannelBusyCallback();
   \   00001B                ; Setup parameters for call to function macTxChannelBusyCallback
   \   00001B   12....       LCALL   `??macTxChannelBusyCallback::?relay`; Banked call to: macTxChannelBusyCallback
   \   00001E   800B         SJMP    ??macCspTxStopIsr_1
    977            }
    978            else
    979            {
    980              MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
   \                     ??macCspTxStopIsr_2:
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6402         XRL     A,#0x2
   \   000023   6003         JZ      ??macCspTxStopIsr_3
   \   000025                ; Setup parameters for call to function halAssertHandler
   \   000025   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    981              macTxAckNotReceivedCallback();
   \                     ??macCspTxStopIsr_3:
   \   000028                ; Setup parameters for call to function macTxAckNotReceivedCallback
   \   000028   12....       LCALL   `??macTxAckNotReceivedCallback::?relay`; Banked call to: macTxAckNotReceivedCallback
    982            }
    983          }
   \                     ??macCspTxStopIsr_1:
   \   00002B   02....       LJMP    ??Subroutine6_0 & 0xFFFF

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??cspReadCountSymbols::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    cspReadCountSymbols

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??cspPrepForTxProgram::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    cspPrepForTxProgram

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxPrepCsmaUnslotted::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxPrepCsmaUnslotted

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxPrepCsmaSlotted::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxPrepCsmaSlotted

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxGoCsma::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxGoCsma

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxPrepSlotted::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxPrepSlotted

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxGoSlotted::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxGoSlotted

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxPrepGreenPower::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxPrepGreenPower

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxGoGreenPower::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxGoGreenPower

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspForceTxDoneIfPending::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspForceTxDoneIfPending

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxRequestAckTimeoutCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxRequestAckTimeoutCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxCancelAckTimeoutCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxCancelAckTimeoutCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxIntIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxIntIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macCspTxStopIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macCspTxStopIsr
    984          
    985          
    986          
    987          /**************************************************************************************************
    988           *                                  Compile Time Integrity Checks
    989           **************************************************************************************************
    990           */
    991          
    992          #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
    993          #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
    994          #endif
    995          
    996          #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
    997          #error "WARNING!  This define value changed.  It was selected for optimum performance."
    998          #endif
    999          
   1000          #if (T2THD_TICKS_PER_SYMBOL == 0)
   1001          #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
   1002          #endif
   1003          
   1004          #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
   1005          #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
   1006          #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
   1007          /*
   1008           *  In other words, the backoff count for the number of superframe rolls over before the
   1009           *  specified number of bits rollover.  For example, if backoff count for a superframe
   1010           *  rolls over at 48, the binary number immediately before a rollover is 00101111.
   1011           *  In this case four bits would work as an alignment mask.  Five would not work though as
   1012           *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
   1013           *  would be expected) because it a new superframe is starting.
   1014           */
   1015          #endif
   1016          #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
   1017          #error "ERROR!  Not enough backoff countdown bits to be practical."
   1018          #endif
   1019          
   1020          
   1021          /**************************************************************************************************
   1022          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   cspPrepForTxProgram
        2      0   -> halAssertHandler
      0     11   cspReadCountSymbols
      2      0   macCspForceTxDoneIfPending
        2      0   -> macCspTxIntIsr
        2      0   -> macTxDoneCallback
      2      0   macCspTxCancelAckTimeoutCallback
      2      0   macCspTxGoCsma
        2      0   -> macRxOn
      2      0   macCspTxGoGreenPower
        2      0   -> macRxOn
      0      9   macCspTxGoSlotted
        0      9   -> macRxHardDisable
      2      0   macCspTxIntIsr
        2      0   -> macTxTimestampCallback
      2      0   macCspTxPrepCsmaSlotted
        2      0   -> cspPrepForTxProgram
      2      0   macCspTxPrepCsmaUnslotted
        2      0   -> cspPrepForTxProgram
      2      0   macCspTxPrepGreenPower
        2      0   -> cspPrepForTxProgram
      2      0   macCspTxPrepSlotted
        2      0   -> cspPrepForTxProgram
      0     11   macCspTxRequestAckTimeoutCallback
        0     11   -> cspReadCountSymbols
        0     11   -> halAssertHandler
      2      0   macCspTxReset
      2      0   macCspTxStopIsr
        2      0   -> halAssertHandler
        2      0   -> macTxAckNotReceivedCallback
        2      0   -> macTxChannelBusyCallback
        2      0   -> macTxDoneCallback


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      15  ??Subroutine4_0
       6  ??Subroutine5_0
       7  ??Subroutine6_0
       6  ?Subroutine0
      11  ?Subroutine1
      10  ?Subroutine2
      12  ?Subroutine3
       1  RFIRQF1
       1  RFST
       1  S1CON
       1  T2CSPCFG
       1  T2IRQF
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MSEL
       1  _A_IEN0
      75  cspPrepForTxProgram
       6  cspPrepForTxProgram::?relay
      35  cspReadCountSymbols
       6  cspReadCountSymbols::?relay
      36  macCspForceTxDoneIfPending
       6  macCspForceTxDoneIfPending::?relay
      13  macCspTxCancelAckTimeoutCallback
       6  macCspTxCancelAckTimeoutCallback::?relay
      57  macCspTxGoCsma
       6  macCspTxGoCsma::?relay
      15  macCspTxGoGreenPower
       6  macCspTxGoGreenPower::?relay
      81  macCspTxGoSlotted
       6  macCspTxGoSlotted::?relay
      17  macCspTxIntIsr
       6  macCspTxIntIsr::?relay
      27  macCspTxPrepCsmaSlotted
       6  macCspTxPrepCsmaSlotted::?relay
      30  macCspTxPrepCsmaUnslotted
       6  macCspTxPrepCsmaUnslotted::?relay
      44  macCspTxPrepGreenPower
       6  macCspTxPrepGreenPower::?relay
      12  macCspTxPrepSlotted
       6  macCspTxPrepSlotted::?relay
     198  macCspTxRequestAckTimeoutCallback
       6  macCspTxRequestAckTimeoutCallback::?relay
      14  macCspTxReset
       6  macCspTxReset::?relay
      46  macCspTxStopIsr
       6  macCspTxStopIsr::?relay

 
 767 bytes in segment BANKED_CODE
  90 bytes in segment BANK_RELAYS
  10 bytes in segment SFR_AN
 
 857 bytes of CODE memory
   0 bytes of DATA memory (+ 10 bytes shared)

Errors: none
Warnings: none
